<p id="chapter3" class="h2 p-2">Глава 3: Измерение памяти </p>

<hr class="border-2">

<p class="justify-style">Возможно, удивительно говорить об измерениях почти в самом начале книги. Мы еще практически ничего не сказали о управлении памятью в .NET, а уже рассматриваем связанные с этим инструменты. Это хорошо продуманное решение. Во-первых, с помощью описанных здесь инструментов мы часто будем иллюстрировать конкретные концепции, которые будут обсуждаться позже. Во-вторых, хотя мы стремимся сделать эту книгу сбалансированной, она имеет очень практическое значение. При рассмотрении различных тем мы коснемся реальных проблем и примеров. С помощью инструментов, описанных в этой главе, вы сможете увидеть, как эти проблемы можно выявить и диагностировать. Эти инструменты помогут глубже понять реализацию теоретических концепций. Кроме того, они незаменимы для исследования возникающих проблем.</p>

<p class="justify-style">Не зная, какие инструменты использовать, сложно проверить, есть ли в вашем процессе проблемы с памятью. Вы не знаете, как убедиться в том, что высокое потребление ресурсов ЦП или памяти связано с управлением памятью .NET. Вы не знаете, в чем может быть причина нежелательного наблюдаемого поведения. Правда в том, что не существует одного, супер универсального швейцарского армейского ножа. Часто необходимо использовать несколько инструментов, чтобы понять поведение вашего процесса. Чтобы в полной мере комфортно чувствовать себя в теме управления памятью, лучше всего научиться пользоваться каждым из них. Мы опишем здесь широкий спектр инструментов. С одной стороны, есть коммерческие продукты с удобными в использовании пользовательскими интерфейсами, где все просто, поэтому можно быстро получить много ответов. Однако эти инструменты позволяют только то, что было задумано их создателями, с очень ограниченной настройкой. С другой стороны, существуют низкоуровневые инструменты, такие как WinDbg, для действительно глубокого анализа. Знание десятков волшебных команд, которые следует использовать в правильном порядке, позволит вам расследовать сбои или детали выделенного типа. Между этими крайностями есть много других инструментов, которые всегда являются компромиссом между универсальностью и простотой использования. По нашему опыту, таких коммерческих программ высокого уровня почти всегда достаточно. Но это «почти» имеет большое значение. Время от времени вы будете сталкиваться с проблемой, которую невозможно решить только с помощью этих программ. Другими словами, рано или поздно ваши руки испачкаются смазкой из двигателя. А когда вы не найдете нужный инструмент, написать свой собственный может быть не так уж и сложно. Эта книга покажет вам несколько приемов самостоятельного проведения анализа!</p>

<p class="justify-style">Возможно, вас удивит отсутствие инструментов статического анализа кода среди представленных здесь. Почти все инструменты основаны на анализе времени выполнения. Это связано с тем, что управление памятью во многом зависит от контекста выполнения. Например, даже самый неэффективный фрагмент кода не окажет негативного влияния на процесс, если связанные с ним операции будут выполняться только один раз в час. Статический анализ кода может помочь, но он также может создавать шум и заставлять вас излишне концентрироваться на нерелевантных частях кода.</p>

<p class="justify-style">Написание производительного кода может быть более сложным, чем написание функционального или чистого кода. Это связано с тем, что очень трудно предсказать, как на самом деле будет работать данный фрагмент кода или каковы приемлемые накладные расходы для данного приложения. Существуют инструменты, которые показывают нарушение некоторых пороговых значений. Но даже в этом случае, без глубокого понимания предмета, вы не можете быть уверены, будут ли эти пороговые значения применимы к вашему приложению в вашей конкретной среде. Вот почему эта глава важна: она помогает вам преодолеть разрыв между теорией и практикой.</p>

<p class="justify-style">Средства, используемые для измерения поведения программ .NET, радикально различаются в зависимости от операционной системы. Именно поэтому в главе рассматриваются два самых популярных из них – Windows и Linux. Из-за очень низкой популярности использования .NET на macOS инструменты (кроме инструментов CLI) для этой платформы в этой книге не описываются.</p>

<p class="justify-style">Хотя знания для интерпретации результатов работы этих инструментов будут предоставлены несколько позже в книге, мы приглашаем вас опробовать их во время чтения, хотя бы немного. Благодаря этому вы приобретете некоторое знакомство, которое пригодится в следующих главах. Очевидно, что не стесняйтесь пропускать инструменты, с которыми вы уже знакомы.</p>

<p class="justify-style">Обратите также внимание, что эта глава немного страдает от проблемы «курицы и яйца» — невозможно продемонстрировать практическую сторону многих тем, связанных с сборщиком мусора (GC), не используя описанные здесь инструменты, но эти инструменты часто требуют хорошего понимания самих тем, связанных с GC. Тем не менее, мы решили объединить все инструменты в одной главе, чтобы избежать перегрузки всей книги и дать вам единое место, к которому можно вернуться при необходимости. Поэтому не беспокойтесь, если вы сразу не поймете каждую деталь, описанную здесь. Мы ожидаем, что вы будете время от времени возвращаться к этой главе, используя эти инструменты в своей повседневной работе, с полным пониманием, полученным из этой книги.</p>

<hr class="border-2">
<p id="chapter3-1" class="h3 p-2">Начинайте измерять на ранней стадии</p>

<p class="justify-style">Какое самое важное правило в вопросах оптимизации производительности? Будь то эксперты или просто разработчики с некоторым опытом решения подобных проблем, все отвечают одинаково: начинайте измерять как можно раньше. Вероятно, каждый слышал фразу о том, что преждевременная оптимизация является корнем всех зол. Во-первых, не имеет смысла тратить часы или дни на оптимизацию кода, который имеет незначительное влияние на приложение. А еще хуже то, что это обязательно сделает код неоправданно сложным, увеличивая стоимость его поддержки. Хорошим правилом будет противоположный подход — вместо того чтобы заранее сосредотачиваться на оптимизации, начните с измерений, чтобы выяснить, есть ли вообще конкретные потребности в производительности. И поскольку эта книга посвящена управлению памятью в .NET, это приводит нас к следующему общему правилу — Начинайте измерять работу сборщика мусора (GC) как можно раньше — которое мы представим в конце этой главы.</p>

<p class="justify-style">Каждое измерение может сопровождаться большей или меньшей погрешностью. Кроме того, измерение может мешать наблюдаемому процессу. Мы знаем этот принцип из физики, и в информатике всё обстоит точно так же. Поэтому ответ на вопрос «как измерять» может быть либо очень простым (если не углубляться в детали), либо очень сложным (если учитывать точность). Разные инструменты предоставляют разную степень точности, и мы немного об этом поговорим. Однако статистические рассуждения о погрешностях измерений выходят за рамки этой книги. Просто имейте в виду, что определённые неточности могут возникнуть каждый раз, когда вы что-то измеряете.</p>

<p class="justify-style">Тем не менее, учитывая его важность в контексте измерений, мы хотим выделить здесь несколько ключевых концепций и распространённых заблуждений.</p>

<hr class="border-2">
<p id="chapter3-1-1" class="h4 p-2">Накладные расходы и инвазивность</p>

<p class="justify-style">Когда дело доходит до инструментов профилирования, всегда важно помнить о двух наиболее важных концепциях:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Накладные расходы</span>: Очень сложно найти инструмент, который не замедляет приложение или не потребляет больше ресурсов каким-либо образом. В этом случае мы говорим о накладных расходах инструмента, которые обычно выражаются в процентах. Это означает, например, что время отклика веб-приложения может увеличиться на несколько процентов. Или эти проценты могут ухудшить плавность анимаций в desktop-приложении. Некоторые инструменты вызывают практически незаметные накладные расходы всего в несколько процентов или даже менее одного процента. Такие инструменты с минимальными накладными расходами можно использовать даже в производственной среде. С другой стороны, существуют инструменты, которые замедляют ваше приложение на порядки. Обычно они предоставляют большое количество детальной информации. Однако из-за значительных накладных расходов их использование ограничивается средами разработки или рабочими станциями отдельных разработчиков.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Инвазивность</span>: Эта концепция схожа и касается того, насколько инструмент влияет на поведение приложения. Требуется ли перезапуск приложения для использования инструмента? Нужны ли дополнительные разрешения или установленные расширения? В идеале ненавязчивое решение можно включать и выключать во время работы приложения, не оказывая на него никакого влияния. С другой стороны, полностью навязчивое решение потребует перекомпиляции вашего приложения и повторной его деплоизации в заданную среду.</p>
    </li>
</ul>

<hr class="border-2">
<p id="chapter3-1-2" class="h4 p-2">Выборка против трассировки</p>

<p class="justify-style">Еще одной характеристикой профилирующих инструментов является способ сбора диагностической информации. Существует два основных подхода:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Трассировка или инструментирование</span>: В этом подходе диагностические данные собираются во время конкретных, выделенных событий (отсюда и другое название — событийный). Примером может служить сохранение трассируемых данных при открытии или закрытии файла, при щелчке мышью или при начале сборки мусора. Неоспоримым преимуществом этого решения является точность данных, поскольку они поступают в момент возникновения события. Однако, если такие события происходят очень часто или вычисление их содержимого требует больших затрат, это может вызвать значительные накладные расходы. Поэтому этот вид механизма не используется для частых событий, таких как вход в функцию или возврат из нее, если только вы можете позволить себе такие накладные расходы, например, на локальной рабочей станции разработчика.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Выборка</span>: В этом подходе точность жертвуется ради снижения накладных расходов. Идея состоит в том, чтобы собирать диагностические данные периодически (отсюда и другое название — временной). Чем реже вы это делаете, тем меньше будут накладные расходы, но одновременно с этим уменьшится точность измерений. Типичным примером такого подхода является регулярная проверка стеков вызовов функций на всех процессорах, например, каждые 1 мс. Это позволяет статистически определить, какие функции занимают больше всего времени на выполнение. Хотя, конечно, существует вероятность, что вы можете не зафиксировать информацию о функциях, которые всегда выполняются быстрее, чем за 1 мс.</p>
    </li>
</ul>

<hr class="border-2">
<p id="chapter3-1-3" class="h4 p-2">Дерево вызовов</p>

<p class="justify-style">Одной из часто используемых визуализаций поведения потоков приложения является построение дерева вызовов. В таком дереве каждая вершина представляет одну функцию. Подчиненные вершины представляют другие функции, которые были вызваны данной функцией. Каждая функция также сопровождается некоторыми измерениями, чаще всего общим временем выполнения. На практике для каждой функции очень часто используются две связанные метрики:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Эксклюзивная (Exclusive)</span>: Измеряет значение только для этой функции. В случае времени выполнения это будет время, проведенное непосредственно в этой функции (без учета подчиненных функций).</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Инклюзивная (Inclusive)</span>: Измеряет значение для данной функции и сумму значений всех ее потомков. В случае времени выполнения это будет время, проведенное в самой функции, во всех других функциях, вызванных ею, во всех функциях, вызванных ими, и так далее, рекурсивно.</p>
    </li>
</ul>

<p class="justify-style">Кроме того, иногда определяется процент данного показателя относительно всего исследуемого диапазона. Это известно как инклюзивный % и эксклюзивный % измерений. Рассмотрим пример на <a href="#f-3-1">рисунке 3-1</a>, показывающем результаты гипотетического профилировщика.</p>

<p class="justify-style">Вы видите здесь, что 100% времени работы программы было потрачено в функции main — это составило 3 секунды. Функция main просто вызывает все остальные функции, поэтому такое поведение ожидаемо. Однако только 22% этого времени было потрачено непосредственно в самой функции main; остальное время ушло на выполнение других функций, вызванных ею. Например, 78% времени было потрачено на выполнение функции SomeClass.Method1. Затем 66,7% времени работы программы было затрачено на вызов функции SomeClass.HelperMethod. Обходя это дерево вызовов, вы быстро сможете определить, какие компоненты приложения работают медленнее всего.</p>

<p class="justify-style">Обратите также внимание, что такие деревья обычно представляют агрегированные данные. В примере с <a href="#f-3-1">рисунка 3-1</a> агрегируются все упомянутые вызовы методов. Таким образом, метод main был вызван всего один раз, в то время как метод HelperMethod был вызван 2000 раз (что объясняет, почему его агрегированное инклюзивное время так велико). Следовательно, анализ такого дерева включает поиск методов, которые выполняются долго, или методов, которые сами по себе не являются медленными, но вызываются множество раз.</p>

<figure id="f-3-1" class="figure">
    <img src="content/img/3-1.png" class="img-fluid" alt="Рисунок 3-1" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-1. Пример дерева вызовов, показывающего данные о производительности</figcaption>
</figure>

<p class="justify-style">Текст ...</p>

<p class="justify-style">Текст ...</p>

<p class="justify-style">Текст ...</p>

<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-1-4" class="h4 p-2">Графы объектов</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-1-5" class="h4 p-2">Статистика</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-1-6" class="h4 p-2">Латентность против пропускной способности</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-1-7" class="h4 p-2">Дампы памяти, трассировка, отладка в реальном времени</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2" class="h3 p-2">Окружения Windows и Linux</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-1" class="h4 p-2">Обзор</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-2" class="h4 p-2">VMMap</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-3" class="h4 p-2">Счетчики производительности .NET Framework</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-4" class="h4 p-2">Счетчики .NET Core</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-5" class="h4 p-2">Трассировка событий для Windows</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-6" class="h4 p-2">PerfView</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-7" class="h4 p-2">Инструмент dotnet-trace CLI</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-8" class="h4 p-2">Инструмент dotnet-gcmon CLI</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-9" class="h4 p-2">ProcDump, dotnet-dump</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-10" class="h4 p-2">dotnet-gcdump CLI инструмент</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-11" class="h4 p-2">WinDbg</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-12" class="h4 p-2">dotnet-dump для анализа</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-13" class="h4 p-2">Дизассемблеры и декомпиляторы</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-14" class="h4 p-2">BenchmarkDotNet</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-15" class="h4 p-2">Инструменты от авторов</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-16" class="h4 p-2">Коммерческие инструменты</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-3" class="h3 p-2">Резюме</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-3-1" class="h4 p-2">Правило 5 — Раннее измерение работы сборщика мусора (GC)</p>
<p class="justify-style">Текст ...</p>



<!--
Глава 3: Измерение памяти  
    Начинайте измерять на ранней стадии  
        Накладные расходы и инвазивность  
        Выборка против трассировки  
        Дерево вызовов  
        Графы объектов  
        Статистика  
        Латентность против пропускной способности  
        Дампы памяти, трассировка, отладка в реальном времени  
    Окружения Windows и Linux  
        Обзор  
        VMMap  
        Счетчики производительности .NET Framework  
        Счетчики .NET Core  
        Трассировка событий для Windows  
        PerfView  
        Инструмент dotnet-trace CLI  
        Инструмент dotnet-gcmon CLI  
        ProcDump, dotnet-dump  
        dotnet-gcdump CLI инструмент  
        WinDbg  
        dotnet-dump для анализа  
        Дизассемблеры и декомпиляторы  
        BenchmarkDotNet  
        Инструменты от авторов  
        Коммерческие инструменты  
    Резюме  
      Правило 5 — Раннее измерение работы сборщика мусора (GC)
-->