<p id="chapter4" class="h2 p-2">Глава 4: Основы .NET</p>

<hr class="border-2">

<p class="justify-style">Хотя мы находимся только в четвертой главе, мы уже прошли довольно длинный путь, изучая различные аспекты управления памятью. Они обсуждались в общем виде, чтобы сделать более теоретическое введение в эту тему. Упоминания .NET были редкими, несмотря на то, что это основная тема книги. Пришло время изменить этот баланс. С этой главы и до конца книги .NET будет сопровождать нас постоянно. В этой главе мы рассмотрим его с несколько более широкой перспективы, вы узнаете о некоторых механизмах, лежащих в его основе, и начнем углубляться в темы, связанные с тем, как он управляет памятью. Мы настоятельно рекомендуем вам уделить время и прочитать предыдущие три главы, прежде чем продолжать чтение этой. Отныне мы также будем предполагать наличие базовых знаний о языке ассемблера для платформ x86/x64, так как мы будем углубляться все дальше и дальше в .NET. Если вам нужно освежить знания, прочитайте, например, отличную книгу «Modern X86 Assembly Language Programming 3rd edition» Дэниела Куссвура (Apress, 2023).</p>

<p class="justify-style">Платформа .NET Framework была представлена публике в июле 2000 года на конференции Professional Developers Conference во Флориде. Это продукт, который разрабатывается и используется уже более двух десятилетий. За этот период как богатая коллекция сопровождающих библиотек, так и сама среда выполнения значительно эволюционировали. Разработчикам .NET необходимо хорошо знать базовые темы — знание стандартной библиотеки и синтаксиса C#. Это наш «повседневный хлеб». Кроме того, .NET Core привнес новые функции и инструменты, которые поддерживают не только Windows как платформу. Цель этой главы — немного углубиться в .NET и его основы.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Имейте в виду, что эта книга сосредоточена на управлении памятью, лишь кратко упоминая другие темы, связанные с .NET. Таким образом, не ожидайте, например, подробного описания возможностей языка C# или рассмотрения вопросов многопоточности. Существует множество других замечательных книг и онлайн-материалов, посвященных исключительно этим темам.</p>
  </div>
</div>

<hr class="border-2">
<p id="chapter4-1" class="h3 p-2">Версии .NET</p>

<p class="justify-style">Среда .NET не так однородна, как может показаться на первый взгляд. .NET Framework, предназначенный только для Windows, развивался от версии 1.0 через версии 2.0, 3.5 или 4.0 до текущей версии 4.8. Кроссплатформенный .NET Core начался с версии 1.0, за которой последовали версии 2.x, 3.0 и 3.1, после чего он сменил название на просто «.NET» с версиями 5, 6, 7 и теперь 8. С самого начала вся концепция .NET основывалась на спецификации, называемой Common Language Infrastructure (CLI). Этот фундаментальный технический стандарт (стандартизированный как ECMA-335 и ISO/IEC 23271 в 2003 году) описывает концепцию кода и среды выполнения, которая позволяет использовать его на разных машинах без перекомпиляции. Мы будем ссылаться на него много раз в этой главе, так как нет более надежного источника информации, чем этот.</p>

<p class="justify-style">Описание всех компонентов CLI, включая все варианты реализации и различия между ними, очень заманчиво. Однако мы в основном сосредоточимся на том, как они влияют на тему, которая нас интересует. Сейчас давайте просто взглянем на различные вариации .NET в контексте управления памятью и сборки мусора (Garbage Collection):</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">.NET Framework 1.0–4.8.1</span>: Выпущенный в 2002 году, это коммерческий и наиболее зрелый продукт, известный всем нам. Он доступен уже много лет, и ядро сборщика мусора (Garbage Collector) разрабатывалось и улучшалось от версии к версии. На протяжении многих лет эта тема рассматривалась как «черный ящик», описываемый более или менее поверхностно по случаю выпуска новых версий .NET. Поскольку коммерческий код среды выполнения .NET Framework закрыт, документация, предоставляемая Microsoft, была единственным способом узнать, как работают эти механизмы. Информация была достаточно подробной, что позволяло понимать и диагностировать проблемы с памятью в приложениях. Однако разработчики все же оставались немного неудовлетворенными, особенно если сравнивать это с открытостью исходных кодов, например, в Java.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Shared Source CLI (также известный как Rotor)</span>: Выпущенный в 2002 году (версия 1.0) и 2006 году (версия 2.0), это реализация среды выполнения для образовательных и академических целей. Он никогда не предназначался для запуска производственного кода. Он позволяет заглянуть в многочисленные детали реализации CLR. Даже существует отличная книга «Shared Source CLI Essentials» Дэвида Штуца, Теда Ньюарда и Джеффа Шиллинга (O’Reilly Media, 2003), которая подробно описывает эту реализацию. Однако она не полностью реализовывала «зрелую» версию .NET Framework 2.0. Более того, ее реализация иногда сильно отличалась от полноценной CLR, к сожалению, особенно в области управления памятью. Там был реализован только очень упрощенный сборщик мусора (Garbage Collector).</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">.NET Compact Framework</span>: «Мобильная» версия .NET, начиная с времен Windows CE/Mobile и Xbox 360. Ее сборщик мусора (Garbage Collector) значительно отличался от основной версии и был намного упрощен, например, он не включал концепцию поколений (о которой вы узнаете в следующей главе). Однако это уже историческая система, и вероятно вам больше не нужно о ней беспокоиться. Но множество уроков было извлечено в процессе разработки этой платформы, особенно из-за портирования на различные платформы с разными процессорами. Именно здесь концептуально начался .NET Core.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Silverlight</span>: Плагин для веб-браузера, который позволял запускать веб-приложения как обычные оконные приложения. Поскольку Microsoft начала разработку примерно в то же время, что и .NET Framework 3.0, он был основан на копии среды выполнения того периода.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">.NET Core или просто .NET, начиная с версии 5.0</span>: Многое изменилось с появлением открытой версии .NET. Теперь у нас есть готовый к использованию в производстве код среды выполнения, который мы можем изучать самостоятельно и в деталях. Что еще важнее, код сборщика мусора (Garbage Collector) был практически скопирован сюда из коммерческого кода среды выполнения, поэтому изучение .NET Core дает понимание того, как GC реализован в .NET Framework, особенно учитывая, что новые функции теперь сначала реализуются в .NET Core, а затем переносятся в .NET Framework. .NET Core также является официально поддерживаемым кроссплатформенным решением. Он работает на Windows, Linux и MacOS, а также поддерживает процессоры ARM64.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Windows Phone 7.x, Windows Phone 8.x, и Windows 10 Mobile</span>: Более ранние версии системы были основаны на простом управлении памятью, известном из .NET Compact Framework 3.7. Windows Phone 8.x представил значительные улучшения внутренней среды выполнения .NET, которая была основана на зрелой версии .NET Framework 4.5, унаследовав ее сборщик мусора (Garbage Collector).</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Native AOT (эволюция .NET Native и CoreRT)</span>: Технология, которая позволяет компилировать CIL-код напрямую в машинный код. Она основана на облегченной среде выполнения под названием CoreRT (ранее MRT). Они используют общий код сборщика мусора (Garbage Collector) с .NET Core.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">.NET Micro Framework</span>: Отдельная реализация для небольших устройств с открытым исходным кодом. Наиболее популярным приложением является .NET Gadgeteer, который содержит собственную упрощенную версию сборщика мусора (Garbage Collector). Из-за нишевого и любительского характера этого решения мы не будем рассматривать его в этой книге.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">WinRT</span>: Новый способ предоставления функциональности ОС разработчикам, который представляет собой набор API, используемых для создания приложений в стиле Metro, доступных на языках JavaScript, C++, C# и VB.NET, и призван заменить Win32. Он написан на C++ и, по сути, не является реализацией .NET. Однако он объектно-ориентирован и основан на формате метаданных .NET, поэтому может выглядеть как обычная библиотека .NET (особенно при использовании из .NET).</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Mono</span>: Совершенно отдельная кроссплатформенная реализация CLI с собственным управлением памятью. Знакомство с ней мало что дает для понимания основной темы .NET. Однако существует как минимум два очень популярных решения, основанных на этой технологии — Xamarin, фреймворк для написания мобильных приложений, и Unity, популярный игровой движок. Кроме того, фреймворк Blazor WebAssembly также использует Mono в качестве базовой среды выполнения (перекомпилированной в WASM) для выполнения управляемого кода внутри браузера. Из приведенного списка складывается довольно положительная картина — механизм управления памятью очень похож (если не сказать практически идентичен) для всех основных реализаций CLI, используемых в настоящее время — .NET Framework, .NET Core и той, что используется в .NET Native.</p>
  </li>
</ul>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Эта книга полна объяснений о внутренних механизмах сборщика мусора (Garbage Collector) в .NET, основанных на исходном коде .NET 8. Как мы уже упоминали, существует значительное сходство этой реализации с основной версией .NET Framework и мобильной вариацией. В результате, опора на исходный код .NET Core является очень ценным и всеобъемлющим способом получения информации. В дальнейшем, когда мы будем показывать примеры исходного кода .NET, по умолчанию будем иметь в виду исходный код .NET 8.0, если не указано иное. Мы также ссылаемся на так называемую открытую документацию «Book of the runtime», разработанную параллельно с самой средой выполнения, доступную по адресу <a href="https://github.com/dotnet/runtime/tree/main/docs/design/coreclr/botr" target="_blank">https://github.com/dotnet/runtime/tree/main/docs/design/coreclr/botr</a>. Она содержит много ценной информации о реализации среды выполнения.</p>
  </div>
</div>

<p class="justify-style">Чтобы полностью понять тему управления памятью, вам следует знать некоторые внутренние аспекты .NET. Мы рассмотрим их сейчас, однако, опустив много информации, которая не нужна в данном контексте. Существует множество других ценных источников, где вы найдете больше информации, включая замечательную книгу «CLR via C#» Джеффри Рихтера (Microsoft Press, 2012), «Pro .NET Performance» Саши Гольдштейна (Apress, 2012) и «Writing High-Performance .NET Code» Бена Уотсона (Ben Watson, 2014).</p>

<hr class="border-2">
<p id="chapter4-2" class="h3 p-2">Внутреннее устройство .NET</p>

<p class="justify-style">Когда вы пишете программу на C или C++, компилятор преобразует исходный код в исполняемый файл. Этот файл может быть напрямую выполнен на целевой машине, так как он содержит двоичный код, который процессор может выполнять напрямую.</p>

<p class="justify-style">С другой стороны, среда выполнения .NET имеет множество важных дополнительных обязанностей, чтобы иметь возможность выполнять наши приложения. В отличие от программ, написанных на C или C++, когда вы пишете программу на C#, F# или любом другом языке, совместимом с .NET, она компилируется в CIL (Common Intermediate Language, общий промежуточный язык). Среда выполнения CLR (Common Language Runtime) выполняет множество магических действий, прежде чем приложение сможет запуститься. Над CLR существует более общая концепция всего .NET Framework, включая все стандартные библиотеки и инструменты (поэтому у нас есть различные версии .NET Framework, которые могут или не могут включать изменения в среде выполнения). CLR имеет несколько обязанностей, среди которых можно выделить:</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">JIT-компилятор (Just-in-Time компилятор)</span>: Его функция заключается в преобразовании CIL-кода вызываемых методов в машинный код.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Система типов</span>: Она отвечает за механизмы контроля типов и их совместимости. Она включает, среди прочего, Common Type System (CTS, общую систему типов) и некоторые метаданные (используемые механизмом Reflection).</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Обработка исключений</span>: Она отвечает за обработку исключений как на уровне пользовательской программы, так и на уровне самой среды выполнения. Здесь используются как встроенные механизмы операционных систем (например, Windows SEH, Structured Exception Handling), так и исключения C++.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Управление памятью (часто называемое сборщиком мусора, Garbage Collector)</span>: Это целая часть среды выполнения, которая управляет памятью, используемой средой выполнения и нашими приложениями. Очевидно, одна из ее основных обязанностей — забота об автоматическом освобождении объектов, которые больше не нужны.</p>
  </li>
</ul>

<p class="justify-style">Мы часто разделяем эти обязанности на две основные части:</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Execution Engine (Исполняющая система)</span>: Она отвечает за большинство обязанностей среды выполнения, упомянутых ранее, таких как JIT-компиляция и обработка исключений. В ECMA-335 она называется Virtual Execution System (VES, Виртуальная исполняющая система) и описывается как «ответственная за загрузку и выполнение программ, написанных для CLI. Она предоставляет услуги, необходимые для выполнения управляемого кода и данных, используя метаданные для соединения отдельных сгенерированных модулей во время выполнения».</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Сборщик мусора (Garbage Collector)</span>: Он отвечает за управление памятью, выделение объектов и освобождение областей памяти, которые больше не используются. В ECMA-335 он описывается как «процесс, посредством которого выделяется и освобождается память для управляемых данных».</p>
  </li>
</ul>

<p class="justify-style">Все эти элементы работают вместе, как в хорошо слаженной машине, состоящей из множества больших и маленьких частей. Трудно удалить один из них и ожидать, что вся машина продолжит работать. То же самое относится и к управлению памятью. Мы можем говорить о механизмах управления памятью, но важно понимать, что другие компоненты тесно взаимодействуют с ним. Например, JIT-компилятор создает информацию о времени жизни переменных, которая затем используется сборщиком мусора. Система типов предоставляет информацию, необходимую для принятия ключевых решений — например, имеет ли тип так называемый финализатор. Реализация P/Invoke учитывает механизмы освобождения памяти — например, чтобы учитывать приостановку, когда происходит сборка мусора. Мы часто можем слышать о «управляемом коде» в контексте .NET. Это означает, что код, выполняемый средой выполнения, должен быть способен взаимодействовать с ней. Как говорится в стандарте ECMA-335:</p>

<br>
<div class="card text-bg-warning mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi bi-flag"></i> Определение</div>
  <div class="card-body">
    <p class="card-text justify-style">Управляемый код: Код, который содержит достаточно информации, чтобы CLI мог предоставить набор основных услуг. Например, имея адрес метода внутри кода, CLI должен быть способен найти метаданные, описывающие этот метод. Он также должен уметь обходить стек, обрабатывать исключения, а также сохранять и извлекать информацию о безопасности.</p>
  </div>
</div>

<p class="justify-style">Текст ...</p>

<p class="justify-style">Текст ...</p>

<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-2-1" class="h4 p-2">Пример программы в деталях</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-3" class="h3 p-2">Сборки и домены приложений</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-3-1" class="h4 p-2">Собираемые сборки</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4" class="h3 p-2">Области памяти процесса</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-1" class="h4 p-2">Сценарий 4-1 — Насколько велика моя программа в памяти?</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-2" class="h4 p-2">Сценарий 4-2 — Использование собственной памяти моей программой продолжает расти</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-3" class="h4 p-2">Сценарий 4-3 — Использование виртуальной памяти моей программой продолжает расти</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-4" class="h4 p-2">Сценарий 4-4 — Использование управляемой памяти моей программой продолжает расти с ростом количества сборок</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-5" class="h4 p-2">Сценарий 4-5 — Моя программа не может выгрузить плагины</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5" class="h3 p-2">Система типов</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5-1" class="h4 p-2">Категории типов</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5-2" class="h4 p-2">Хранилище типов</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5-3" class="h4 p-2">Значимые типы</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5-4" class="h4 p-2">Ссылочные типы</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-6" class="h3 p-2">Строки</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-6-1" class="h4 p-2">Интернирование строк</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-6-2" class="h4 p-2">Сценарий 4-6 — Использование памяти моей программой слишком большое</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-7" class="h3 p-2">Упаковка и Распаковка</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-8" class="h3 p-2">Передача по ссылке</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-8-1" class="h4 p-2">Передача по ссылке экземпляра значимого типа</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-8-2" class="h4 p-2">Передача по ссылке экземпляра ссылочного типа</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-9" class="h3 p-2">Null</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-10" class="h3 p-2">Локализация данных типа</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-11" class="h3 p-2">Статические данные</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-11-1" class="h4 p-2">Статические поля</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-11-2" class="h4 p-2">Внутренние статические данные</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-12" class="h3 p-2">Резюме</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-12-1" class="h4 p-2">Структуры</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-12-2" class="h4 p-2">Классы</p>
<p class="justify-style">Текст ...</p>


<!--
Глава 4: Основы .NET
    Версии .NET
    Внутреннее устройство .NET
        Пример программы в деталях
    Сборки и домены приложений
        Собираемые сборки
    Области памяти процесса
        Сценарий 4-1 — Насколько велика моя программа в памяти?
        Сценарий 4-2 — Использование собственной памяти моей программой продолжает расти
        Сценарий 4-3 — Использование виртуальной памяти моей программой продолжает расти
        Сценарий 4-4 — Использование управляемой памяти моей программой продолжает расти с ростом количества сборок
        Сценарий 4-5 — Моя программа не может выгрузить плагины
    Система типов
        Категории типов
        Хранилище типов
        Значимые типы
        Ссылочные типы
    Строки
        Интернирование строк
        Сценарий 4-6 — Использование памяти моей программой слишком большое
    Упаковка и Распаковка
    Передача по ссылке
        Передача по ссылке экземпляра значимого типа
        Передача по ссылке экземпляра ссылочного типа
    Null
    Локализация данных типа
    Статические данные
        Статические поля
        Внутренние статические данные
    Резюме
        Структуры
        Классы
-->
