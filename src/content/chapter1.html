<p id="chapter1" class="h2 p-2">Глава 1: Базовые концепции</p>

<p class="left-style">
  Давайте начнем с простого, но важного вопроса. Когда вам следует беспокоиться об управлении памятью .NET, если все автоматизировано? Стоит ли вообще беспокоиться? Как вы, вероятно, ожидаете, учитывая тот факт, что мы написали такую ​​книгу, мы настоятельно рекомендуем вам думать о памяти в ситуации каждого разработчика. Часто это то, что составляет разницу между проверкой концепции на машине разработчика и готовым к производству кодом. Оптимален ли он с точки зрения использования процессора и памяти? Является ли он поддерживаемым, тестируемым, открытым для расширения, но закрытым для модификации? Соответствует ли ваш код SOLID? Мы считаем, что все эти вопросы отличают новичков от более продвинутых, опытных программистов. Первые в основном заинтересованы в том, чтобы выполнить работу, и не слишком заботятся о вышеупомянутых нефункциональных аспектах своей работы. Последние достаточно опытны, чтобы иметь достаточно «умственной вычислительной мощности», чтобы оценить качество своей работы. Мы считаем, что все хотят быть такими. Но это, конечно, нетривиальная задача. Написать элегантный код без каких-либо ошибок, с выполнением каждого возможного нефункционального требования, действительно сложно.
</p>
<p class="left-style muted">
  Но должно ли такое стремление к превосходству быть единственной мотивацией для получения глубоких знаний об управлении памятью .NET? Разрушение памяти, вызывающее 
  <a class="fw-bolder" data-bs-toggle="modal" data-bs-target="#AccessViolationExceptionModal">
    AccessViolationException
  </a>
  чрезвычайно редко. Редкий сценарий неконтролируемого увеличения использования памяти также может вызвать то же исключение. У тебя есть о чем беспокоиться? Благодаря утонченности времени выполнения .NET вам не нужно много думать об аспектах памяти. Но, с другой стороны, при участии в анализе задач производительности крупных приложений на основе .NET проблемы с потреблением памяти всегда были высокими в списке проблем. Это вызывает проблемы в долгосрочном взгляде, если у вас есть утечка памяти после дней непрерывной работы? В Интернете вы можете найти забавный мем об утечке памяти, которая не была зафиксирована в программном обеспечении какой-то конкретной ракеты боевых действий, потому что было достаточно памяти до того, как ракета достигла своего пункта назначения. Ваша система такая бывшая ракета? Может быть, вы могли бы использовать только два сервера вместо десяти? Кроме того, вы должны подумать о потреблении памяти, особенно во времена облачных вычислений без серверов. Одним из примеров может быть функции Azure, которые выставлены на основе меры, называемой «гигабайтными секундами» (GB-S). Он рассчитывается путем умножения среднего размера памяти в гигабайтах к моменту секунд, необходимых для выполнения конкретной функции. Потребление памяти напрямую приводит к потраченным деньгам.
</p>

<p class="left-style">
  В каждом случае вы начинаете понимать, что понятия не имеете, где начать искать настоящую причину и значимые измерения. Это то место, где вы начинаете понимать, что стоит разобраться во внутренних механизмах ваших приложений и базовой среде выполнения.
</p>

<p class="left-style">
  Чтобы глубоко понять управление памятью в .NET, лучше всего начать с нуля. Неважно, являетесь ли вы начинающим программистом или очень продвинутым. Важно, чтобы вы прошли теоретическое введение в этой главе: это установит необходимый уровень знаний и понимания концепций, которые будут использоваться в остальной части книги. Чтобы это не было просто скучной теорией, иногда мы ссылаемся на конкретные технологии. Если вас интересует управление памятью в истории компьютерных наук, обратитесь к бесплатной главе, доступной по адресу 
  <a href="https://prodotnetmemory.com/assets/files/Chapter01_History.pdf">Chapter01_History.pdf</a>
</p>

<hr class="border-2">

<p id="chapter1-1" class="h3 p-2">Термины, связанные с памятью</p>

<p class="left-style">Прежде чем начать, полезно рассмотреть некоторые очень важные определения, без которых трудно представить обсуждение темы памяти:</p>

<ul class="list-group list-group-flush">
    <li class="list-group-item"><span class="fw-bold">Бит</span>: Это наименьшая единица информации, используемая в компьютерных технологиях. Она представляет два возможных состояния, обычно означающих числовые значения 0 и 1 или логические значения true и false. Мы кратко упоминаем, как современные компьютеры хранят отдельные биты в Главе 2. Для представления больших числовых значений необходимо использовать комбинацию нескольких бит для кодирования их в виде двоичного числа, что объясняется следующим образом. При указании размера данных биты указываются строчной буквой b.</p></li>
    <li class="list-group-item"><span class="fw-bold">Двоичное число</span>: это целое числовое значение, представленное в виде последовательности битов. Каждый последующий бит определяет вклад последовательной степени 2 в сумму данного значения. Например, для представления числа 5 используются три последовательных бита со значениями 1, 0 и 1, поскольку 1x1 + 0x2 + 1x4 равно 5. Двоичное число длиной n бит может представлять максимальное значение 2^n – 1. Также часто существует дополнительный бит, выделенный для представления знака значения для кодирования как положительных, так и отрицательных чисел. Существуют также другие, более сложные способы кодирования числовых значений в двоичной форме, особенно для чисел с плавающей точкой.</p></li>
    <li class="list-group-item"><span class="fw-bold">Двоичный код</span>: Вместо числовых значений последовательность битов может представлять определенный набор различных данных, например, символов текста. Каждая последовательность битов назначается определенным данным. Самым базовым и самым популярным на протяжении многих лет был код ASCII, который использует 7-битный двоичный код для представления текста и других символов. Существуют и другие важные двоичные коды, такие как коды операций, кодирующие инструкции, сообщающие компьютеру, что он должен делать.</p></li>
    <li class="list-group-item"><span class="fw-bold">Байт</span>: Исторически это была последовательность битов для кодирования одного символа текста с использованием указанного двоичного кода. Наиболее распространенный размер байта составляет 8 бит, хотя он зависит от архитектуры компьютера и может варьироваться в зависимости от модели. Из-за этой неоднозначности существует более точный термин октет, который означает именно 8-битную единицу данных. Тем не менее, фактическим стандартом является понимание байта как 8-битного значения длины, и как таковой он стал неоспоримым стандартом для определения размеров данных. В настоящее время вряд ли он встретит что-то иное, чем стандартная архитектура с 8-битными байтами. При указании размера данных байты указываются с заглавной буквой B.</p></li>
</ul>

<p class="left-style">Указывая размер данных, мы используем наиболее распространенные кратные (префиксы), определяющие их порядок величины. Это является причиной постоянной путаницы и недопонимания. Такие чрезвычайно популярные термины, как кило, мега и гига, означают умножение тысяч. Один кило равен 1000 (и мы обозначаем его строчной буквой k), один мега равен 1 миллиону (заглавной буквой M) и так далее. С другой стороны, иногда популярным подходом является выражение порядков величины в последовательных умножениях 1024. В таких случаях мы говорим об одном киби, что равно 1024 (обозначается как Ki), один меби равен 1024*1024 (обозначается как Mi), один гиби (Gi) равен 1024*1024*1024 и так далее. Это вносит общую двусмысленность. Когда кто-то говорит об 1 «гигабайте», он может думать о 1 миллиарде байт (1 ГБ) или 1024^3 байт (1 ГиБ) в зависимости от контекста. На практике очень немногие заботятся о точном использовании этих префиксов. В настоящее время принято указывать размер модулей памяти в компьютерах как гигабайты (ГБ), когда они на самом деле являются гибибайтами (ГиБ) или наоборот в случае с жесткими дисками. Даже стандарт JEDEC 100B.01 «Термины, определения и буквенные обозначения для микрокомпьютеров, микропроцессоров и интегральных схем памяти» ссылается на общее использование K, M и G как умножений 1024, не осуждая его явно. В таких ситуациях нам остается только полагаться на здравый смысл в понимании этих префиксов из контекста.</p>

<p class="left-style">В настоящее время мы очень привыкли к таким терминам, как ОЗУ или постоянное хранилище, установленное в наших компьютерах. Даже умные часы теперь оснащены 32 ГиБ ОЗУ! Вы можете легко забыть, что первые компьютеры не были оснащены такой роскошью. Можно сказать, что они не были оснащены ничем. На <a href="#f-1-1">рисунке 1-1</a> показаны различные элементы компьютера:</p>

<ul class="list-group list-group-flush">
  <li class="list-group-item"><span class="fw-bold">Память</span>: отвечает за хранение данных и самой программы. Способ реализации памяти со временем значительно изменился, начиная с вышеупомянутых перфокарт, через магнитные типы и электронно-лучевые трубки, до используемых в настоящее время транзисторов. Память можно разделить на две основные подкатегории:</li>
  <ul class="list-group list-group+ list-group-flush ms-3">
    <li class="list-group-item"><span class="fw-bold fst-italic">Оперативная память (ОЗУ)</span>: позволяет считывать данные в одно и то же время доступа независимо от области памяти, к которой осуществляется доступ. На практике, как вы увидите в Главе 2, современная память удовлетворяет этому условию лишь приблизительно по технологическим причинам.</li>
    <li class="list-group-item"><span class="fw-bold fst-italic">Неравномерная память доступа</span>: в отличие от ОЗУ, время, необходимое для доступа к памяти, зависит от ее расположения на физическом носителе. Это, очевидно, включает в себя перфокарты, магнитные типы, классические жесткие диски, CD и DVD и т. д., где носители информации должны быть позиционированы (например, повернуты) в правильное положение перед доступом.</li>
  </ul>
  <li class="list-group-item"><span class="fw-bold">Адрес</span>: представляет собой определенное местоположение во всей области памяти. Обычно выражается в байтах, поскольку один байт — это наименьшая возможная адресуемая гранулярность на многих платформах.</li>
  <li class="list-group-item"><span class="fw-bold">Арифметико-логическое устройство (АЛУ)</span>: отвечает за выполнение таких операций, как сложение и вычитание. Это ядро ​​компьютера, где выполняется большая часть работы. В настоящее время компьютеры включают в себя более одного АЛУ, что позволяет распараллеливать вычисления.</li>
  <li class="list-group-item"><span class="fw-bold">Блок управления</span>: декодирует инструкции программы (коды операций), считанные из памяти. На основе описания внутренней инструкции он знает, какую арифметическую или логическую операцию следует выполнить и над какими данными.</li>
  <li class="list-group-item"><span class="fw-bold">Регистр</span>: ячейка памяти, быстро доступная из АЛУ и/или блока управления (которые мы можем вместе называть исполнительными блоками), обычно содержащаяся в ней. Упомянутые выше аккумуляторы представляют собой специальный, упрощенный вид регистров. Регистры чрезвычайно быстры с точки зрения времени доступа, и фактически нет данных более близких к исполнительным блокам.</li>
  <li class="list-group-item"><span class="fw-bold">Слово</span>: Базовая единица данных фиксированного размера, используемая в конкретном компьютерном проектировании. Она отражена во многих областях проектирования, таких как размер большинства регистров, максимальный адрес или самый большой блок данных, передаваемый за одну операцию. Чаще всего она выражается в количестве бит (называемых размером слова или длиной слова). Большинство современных компьютеров являются 32- или 64-разрядными, поэтому они имеют длину слова 32 и 64 бита соответственно, регистры длиной 32 или 64 бита и т. д.</li>
</ul>

<p class="left-style">Блок управления использует дополнительный регистр, называемый указателем инструкций (IP) или счетчиком программ (PC), для указания на текущую выполняемую инструкцию. Обычное выполнение программы так же просто, как увеличение адреса, хранящегося в PC, на следующие инструкции. Такие вещи, как циклы или переходы, так же просты, как изменение значения указателя инструкций на следующую инструкцию для выполнения, обозначая, какую инструкцию мы хотим, чтобы программа продолжила выполнять.</p>

<figure id="f-1-1" class="figure">
  <img src="content/img/1-1.png" class="img-fluid" alt="Рисунок 1-1" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-1. Компьютерная диаграмма с хранимой программой – память + указатель инструкций</figcaption>
</figure>

<p class="left-style">Первые компьютеры программировались с использованием двоичного кода, который напрямую описывал инструкции для выполнения. Однако с ростом сложности программ это решение становилось все более обременительным. Был разработан новый язык программирования (обозначаемый как языки программирования второго поколения – 2GL) для описания кода более доступным способом с помощью так называемого ассемблерного кода. Это текстовое и очень краткое описание отдельных инструкций, выполняемых процессором. Это было намного удобнее, чем прямое двоичное кодирование. Затем были разработаны даже языки более высокого уровня (3GL), такие как известные C, C++ или Pascal.</p>

<p class="left-style">Для нас интересно то, что все эти языки должны быть преобразованы из текстовой в двоичную форму, а затем помещены в память компьютера. Это преобразование называется компиляцией, а инструмент, который его запускает, называется компилятором. В случае ассемблерного кода мы скорее называем его сборкой с помощью инструмента ассемблера. В конечном итоге результатом является программа в формате двоичного кода, которая может быть позже выполнена – последовательность кодов операций и их аргументов (операндов).</p>

<p class="left-style">Вооружившись этими базовыми знаниями, вы теперь можете начать свой путь в управлении памятью!</p>

<hr class="border-2">

<p id="chapter1-1-1" class="h4 p2">Статическое выделение</p>

<p class="left-style">Большинство самых первых языков программирования допускали только статическое выделение памяти — объем и точное местоположение необходимой памяти должны были быть известны во время компиляции, еще до выполнения программы. С фиксированными и предопределенными размерами управление памятью было тривиальным. Все основные языки программирования «древних времен», начиная с машинного или ассемблерного кода и заканчивая первыми версиями FORTRAN и ALGOL, имели такие ограниченные возможности. Но у них также есть много недостатков. Статическое выделение памяти может легко привести к неэффективному использованию памяти. Не зная заранее, какой объем данных будет обработан, как мы вычислим, сколько памяти нам следует выделить? Это делает программы ограниченными и негибкими. В общем, такую ​​программу нужно снова компилировать для обработки больших объемов данных.</p>

<p class="left-style">В самых первых компьютерах все выделения были статическими, поскольку используемые ячейки памяти (аккумулятор, регистры или ячейки оперативной памяти) определялись во время кодирования программы. Поэтому определенные «переменные» существовали в течение всего жизненного цикла программы. В настоящее время мы все еще используем статическое распределение в том смысле, что при создании статических глобальных переменных и тому подобных, хранящихся в специальном сегменте данных программы. В последующих главах вы увидите, где они хранятся в случае программ .NET.</p>

<hr class="border-2">

<p id="chapter1-1-2" class="h4 p2">Регистровая машина</p>

<p class="left-style">Компьютеры используют регистры (или аккумуляторы как частный случай) для работы с арифметико-логическими устройствами (АЛУ). Машины, которые полагаются на эту конструкцию, называются регистровыми машинами. Это потому, что при выполнении программ на таком компьютере мы фактически производим вычисления в регистрах. Если мы хотим сложить, разделить или сделать что-то еще, мы должны загрузить соответствующие данные из памяти в соответствующие регистры. Затем мы вызываем определенную инструкцию, чтобы вызвать соответствующую операцию над ними, а затем еще одну, чтобы сохранить результат из одного из регистров обратно в память.</p>

<p class="left-style">Предположим, мы хотим написать программу, которая вычисляет выражение s=x+(2*y)+z на компьютере с двумя регистрами — A и B. Предположим также, что</p>

<hr class="border-2">
<p id="chapter1-1-3" class="h4 p2">Стек</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-1-4" class="h4 p2">Стековая машина</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-1-5" class="h4 p2">Указатель</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-1-6" class="h4 p2">Куча</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-2" class="h3 p-2">Ручное управление памятью</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-3" class="h3 p-2">Автоматическое управление памятью</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-3-1" class="h4 p2">Аллокатор, мутатор и сборщик</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-4" class="h3 p-2">Подсчет ссылок</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-5" class="h3 p-2">Отслеживающий сборщик</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-6" class="h3 p-2">Резюме</p>
<p class="left-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-6-1" class="h4 p2">Правило 1 — Самообразование</p>
<!--
Глава 1: Базовые концепции
    Термины, связанные с памятью
        Статическое выделение
        Регистровая машина.
        Стек
        Стековая машина
        Указатель
        Куча
    Ручное управление памятью
    Автоматическое управление памятью
        Аллокатор, мутатор и сборщик
    Подсчет ссылок
    Отслеживающий сборщик
        Фаза маркировки
    Резюме
        Правило 1 — Самообразование
-->

<!-- Modal -->
<div class="modal fade" id="AccessViolationExceptionModal" tabindex="-1" aria-labelledby="AccessViolationExceptionModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="AccessViolationExceptionModalLabel">AccessViolationException</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <span class="fw-bolder">AccessViolationException</span> или другие повреждения кучи часто могут быть вызваны автоматическим управлением памятью, не потому что это причина, а потому что это самый тяжелый компонент, связанный с памятью в среде. Таким образом, у него самая большая вероятность обнаружить любые несогласованные состояния памяти.
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>