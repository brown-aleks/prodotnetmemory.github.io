<p id="chapter1" class="h2 p-2">Глава 1: Базовые концепции</p>

<hr class="border-2">

<p class="justify-style">
  Давайте начнем с простого, но важного вопроса. Когда вам следует беспокоиться об управлении памятью .NET, если все автоматизировано? Стоит ли вообще беспокоиться? Как вы, вероятно, ожидаете, учитывая тот факт, что мы написали такую ​​книгу, мы настоятельно рекомендуем вам думать о памяти в ситуации каждого разработчика. Часто это то, что составляет разницу между проверкой концепции на машине разработчика и готовым к производству кодом. Оптимален ли он с точки зрения использования процессора и памяти? Является ли он поддерживаемым, тестируемым, открытым для расширения, но закрытым для модификации? Соответствует ли ваш код SOLID? Мы считаем, что все эти вопросы отличают новичков от более продвинутых, опытных программистов. Первые в основном заинтересованы в том, чтобы выполнить работу, и не слишком заботятся о вышеупомянутых нефункциональных аспектах своей работы. Последние достаточно опытны, чтобы иметь достаточно «умственной вычислительной мощности», чтобы оценить качество своей работы. Мы считаем, что все хотят быть такими. Но это, конечно, нетривиальная задача. Написать элегантный код без каких-либо ошибок, с выполнением каждого возможного нефункционального требования, действительно сложно.</p>

<p class="justify-style muted">
  Но должно ли такое стремление к превосходству быть единственной мотивацией для получения глубоких знаний об управлении памятью .NET? Разрушение памяти, вызывающее <a class="fw-bolder" data-bs-toggle="modal" data-bs-target="#AccessViolationExceptionModal">AccessViolationException</a>чрезвычайно редко. Редкий сценарий неконтролируемого увеличения использования памяти также может вызвать то же исключение. У тебя есть о чем беспокоиться? Благодаря утонченности времени выполнения .NET вам не нужно много думать об аспектах памяти. Но, с другой стороны, при участии в анализе задач производительности крупных приложений на основе .NET проблемы с потреблением памяти всегда были высокими в списке проблем. Это вызывает проблемы в долгосрочном взгляде, если у вас есть утечка памяти после дней непрерывной работы? В Интернете вы можете найти забавный мем об утечке памяти, которая не была зафиксирована в программном обеспечении какой-то конкретной ракеты боевых действий, потому что было достаточно памяти до того, как ракета достигла своего пункта назначения. Ваша система такая бывшая ракета? Может быть, вы могли бы использовать только два сервера вместо десяти? Кроме того, вы должны подумать о потреблении памяти, особенно во времена облачных вычислений без серверов. Одним из примеров может быть функции Azure, которые выставлены на основе меры, называемой «гигабайтными секундами» (GB-S). Он рассчитывается путем умножения среднего размера памяти в гигабайтах к моменту секунд, необходимых для выполнения конкретной функции. Потребление памяти напрямую приводит к потраченным деньгам.
</p>

<p class="justify-style">
  В каждом случае вы начинаете понимать, что понятия не имеете, где начать искать настоящую причину и значимые измерения. Это то место, где вы начинаете понимать, что стоит разобраться во внутренних механизмах ваших приложений и базовой среде выполнения.
</p>

<p class="justify-style">
  Чтобы глубоко понять управление памятью в .NET, лучше всего начать с нуля. Неважно, являетесь ли вы начинающим программистом или очень продвинутым. Важно, чтобы вы прошли теоретическое введение в этой главе: это установит необходимый уровень знаний и понимания концепций, которые будут использоваться в остальной части книги. Чтобы это не было просто скучной теорией, иногда мы ссылаемся на конкретные технологии. Если вас интересует управление памятью в истории компьютерных наук, обратитесь к бесплатной главе, доступной по адресу <a href="https://prodotnetmemory.com/assets/files/Chapter01_History.pdf">Chapter01_History.pdf</a></p>

<hr class="border-2">

<p id="chapter1-1" class="h3 p-2">Термины, связанные с памятью</p>

<p class="justify-style">Прежде чем начать, полезно рассмотреть некоторые очень важные определения, без которых трудно представить обсуждение темы памяти:</p>

<ul class="bullet-list ms-1">
    <li>
      <p class="justify-style"><span class="fw-bold">Бит</span>: Это наименьшая единица информации, используемая в компьютерных технологиях. Она представляет два возможных состояния, обычно означающих числовые значения 0 и 1 или логические значения true и false. Мы кратко упоминаем, как современные компьютеры хранят отдельные биты в Главе 2. Для представления больших числовых значений необходимо использовать комбинацию нескольких бит для кодирования их в виде двоичного числа, что объясняется следующим образом. При указании размера данных биты указываются строчной буквой b.</p>
    </li>
    <li>
      <p class="justify-style"><span class="fw-bold">Двоичное число</span>: это целое числовое значение, представленное в виде последовательности битов. Каждый последующий бит определяет вклад последовательной степени 2 в сумму данного значения. Например, для представления числа 5 используются три последовательных бита со значениями 1, 0 и 1, поскольку 1x1 + 0x2 + 1x4 равно 5. Двоичное число длиной n бит может представлять максимальное значение 2^n – 1. Также часто существует дополнительный бит, выделенный для представления знака значения для кодирования как положительных, так и отрицательных чисел. Существуют также другие, более сложные способы кодирования числовых значений в двоичной форме, особенно для чисел с плавающей точкой.</p>
    </li>
    <li>
      <p class="justify-style"><span class="fw-bold">Двоичный код</span>: Вместо числовых значений последовательность битов может представлять определенный набор различных данных, например, символов текста. Каждая последовательность битов назначается определенным данным. Самым базовым и самым популярным на протяжении многих лет был код ASCII, который использует 7-битный двоичный код для представления текста и других символов. Существуют и другие важные двоичные коды, такие как коды операций, кодирующие инструкции, сообщающие компьютеру, что он должен делать.</p>
    </li>
    <li>
      <p class="justify-style"><span class="fw-bold">Байт</span>: Исторически это была последовательность битов для кодирования одного символа текста с использованием указанного двоичного кода. Наиболее распространенный размер байта составляет 8 бит, хотя он зависит от архитектуры компьютера и может варьироваться в зависимости от модели. Из-за этой неоднозначности существует более точный термин октет, который означает именно 8-битную единицу данных. Тем не менее, фактическим стандартом является понимание байта как 8-битного значения длины, и как таковой он стал неоспоримым стандартом для определения размеров данных. В настоящее время вряд ли он встретит что-то иное, чем стандартная архитектура с 8-битными байтами. При указании размера данных байты указываются с заглавной буквой B.</p>
    </li>
</ul>

<p class="justify-style">Указывая размер данных, мы используем наиболее распространенные кратные (префиксы), определяющие их порядок величины. Это является причиной постоянной путаницы и недопонимания. Такие чрезвычайно популярные термины, как кило, мега и гига, означают умножение тысяч. Один кило равен 1000 (и мы обозначаем его строчной буквой k), один мега равен 1 миллиону (заглавной буквой M) и так далее. С другой стороны, иногда популярным подходом является выражение порядков величины в последовательных умножениях 1024. В таких случаях мы говорим об одном киби, что равно 1024 (обозначается как Ki), один меби равен 1024*1024 (обозначается как Mi), один гиби (Gi) равен 1024*1024*1024 и так далее. Это вносит общую двусмысленность. Когда кто-то говорит об 1 «гигабайте», он может думать о 1 миллиарде байт (1 ГБ) или 1024^3 байт (1 ГиБ) в зависимости от контекста. На практике очень немногие заботятся о точном использовании этих префиксов. В настоящее время принято указывать размер модулей памяти в компьютерах как гигабайты (ГБ), когда они на самом деле являются гибибайтами (ГиБ) или наоборот в случае с жесткими дисками. Даже стандарт JEDEC 100B.01 «Термины, определения и буквенные обозначения для микрокомпьютеров, микропроцессоров и интегральных схем памяти» ссылается на общее использование K, M и G как умножений 1024, не осуждая его явно. В таких ситуациях нам остается только полагаться на здравый смысл в понимании этих префиксов из контекста.</p>

<p class="justify-style">В настоящее время мы очень привыкли к таким терминам, как ОЗУ или постоянное хранилище, установленное в наших компьютерах. Даже умные часы теперь оснащены 32 ГиБ ОЗУ! Вы можете легко забыть, что первые компьютеры не были оснащены такой роскошью. Можно сказать, что они не были оснащены ничем. На <a href="#f-1-1">рисунке 1-1</a> показаны различные элементы компьютера:</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style"><span class="fw-bold">Память</span>: отвечает за хранение данных и самой программы. Способ реализации памяти со временем значительно изменился, начиная с вышеупомянутых перфокарт, через магнитные типы и электронно-лучевые трубки, до используемых в настоящее время транзисторов. Память можно разделить на две основные подкатегории:</p>
  </li>
  <ul>
    <li>
      <p class="justify-style"><span class="fw-bold fst-italic">Оперативная память (ОЗУ)</span>: позволяет считывать данные в одно и то же время доступа независимо от области памяти, к которой осуществляется доступ. На практике, как вы увидите в Главе 2, современная память удовлетворяет этому условию лишь приблизительно по технологическим причинам.</p>
    </li>
    <li>
      <p class="justify-style"><span class="fw-bold fst-italic">Неравномерная память доступа</span>: в отличие от ОЗУ, время, необходимое для доступа к памяти, зависит от ее расположения на физическом носителе. Это, очевидно, включает в себя перфокарты, магнитные типы, классические жесткие диски, CD и DVD и т. д., где носители информации должны быть позиционированы (например, повернуты) в правильное положение перед доступом.</p>
    </li>
  </ul>
  <li>
    <p class="justify-style"><span class="fw-bold">Адрес</span>: представляет собой определенное местоположение во всей области памяти. Обычно выражается в байтах, поскольку один байт — это наименьшая возможная адресуемая гранулярность на многих платформах.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold">Арифметико-логическое устройство (АЛУ)</span>: отвечает за выполнение таких операций, как сложение и вычитание. Это ядро ​​компьютера, где выполняется большая часть работы. В настоящее время компьютеры включают в себя более одного АЛУ, что позволяет распараллеливать вычисления.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold">Блок управления</span>: декодирует инструкции программы (коды операций), считанные из памяти. На основе описания внутренней инструкции он знает, какую арифметическую или логическую операцию следует выполнить и над какими данными.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold">Регистр</span>: ячейка памяти, быстро доступная из АЛУ и/или блока управления (которые мы можем вместе называть исполнительными блоками), обычно содержащаяся в ней. Упомянутые выше аккумуляторы представляют собой специальный, упрощенный вид регистров. Регистры чрезвычайно быстры с точки зрения времени доступа, и фактически нет данных более близких к исполнительным блокам.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold">Слово</span>: Базовая единица данных фиксированного размера, используемая в конкретном компьютерном проектировании. Она отражена во многих областях проектирования, таких как размер большинства регистров, максимальный адрес или самый большой блок данных, передаваемый за одну операцию. Чаще всего она выражается в количестве бит (называемых размером слова или длиной слова). Большинство современных компьютеров являются 32- или 64-разрядными, поэтому они имеют длину слова 32 и 64 бита соответственно, регистры длиной 32 или 64 бита и т. д.</p>
  </li>
</ul>

<p class="justify-style">Блок управления использует дополнительный регистр, называемый указателем инструкций (IP) или счетчиком программ (PC), для указания на текущую выполняемую инструкцию. Обычное выполнение программы так же просто, как увеличение адреса, хранящегося в PC, на следующие инструкции. Такие вещи, как циклы или переходы, так же просты, как изменение значения указателя инструкций на следующую инструкцию для выполнения, обозначая, какую инструкцию мы хотим, чтобы программа продолжила выполнять.</p>

<figure id="f-1-1" class="figure">
  <img src="content/img/1-1.png" class="img-fluid" alt="Рисунок 1-1" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-1. Компьютерная диаграмма с хранимой программой – память + указатель инструкций</figcaption>
</figure>

<p class="justify-style">Первые компьютеры программировались с использованием двоичного кода, который напрямую описывал инструкции для выполнения. Однако с ростом сложности программ это решение становилось все более обременительным. Был разработан новый язык программирования (обозначаемый как языки программирования второго поколения – 2GL) для описания кода более доступным способом с помощью так называемого ассемблерного кода. Это текстовое и очень краткое описание отдельных инструкций, выполняемых процессором. Это было намного удобнее, чем прямое двоичное кодирование. Затем были разработаны даже языки более высокого уровня (3GL), такие как известные C, C++ или Pascal.</p>

<p class="justify-style">Для нас интересно то, что все эти языки должны быть преобразованы из текстовой в двоичную форму, а затем помещены в память компьютера. Это преобразование называется компиляцией, а инструмент, который его запускает, называется компилятором. В случае ассемблерного кода мы скорее называем его сборкой с помощью инструмента ассемблера. В конечном итоге результатом является программа в формате двоичного кода, которая может быть позже выполнена – последовательность кодов операций и их аргументов (операндов).</p>

<p class="justify-style">Вооружившись этими базовыми знаниями, вы теперь можете начать свой путь в управлении памятью!</p>

<hr class="border-2">

<p id="chapter1-1-1" class="h4 p2">Статическое выделение</p>

<p class="justify-style">Большинство самых первых языков программирования допускали только статическое выделение памяти — объем и точное местоположение необходимой памяти должны были быть известны во время компиляции, еще до выполнения программы. С фиксированными и предопределенными размерами управление памятью было тривиальным. Все основные языки программирования «древних времен», начиная с машинного или ассемблерного кода и заканчивая первыми версиями FORTRAN и ALGOL, имели такие ограниченные возможности. Но у них также есть много недостатков. Статическое выделение памяти может легко привести к неэффективному использованию памяти. Не зная заранее, какой объем данных будет обработан, как мы вычислим, сколько памяти нам следует выделить? Это делает программы ограниченными и негибкими. В общем, такую ​​программу нужно снова компилировать для обработки больших объемов данных.</p>

<p class="justify-style">В самых первых компьютерах все выделения были статическими, поскольку используемые ячейки памяти (аккумулятор, регистры или ячейки оперативной памяти) определялись во время кодирования программы. Поэтому определенные «переменные» существовали в течение всего жизненного цикла программы. В настоящее время мы все еще используем статическое распределение в том смысле, что при создании статических глобальных переменных и тому подобных, хранящихся в специальном сегменте данных программы. В последующих главах вы увидите, где они хранятся в случае программ .NET.</p>

<hr class="border-2">

<p id="chapter1-1-2" class="h4 p2">Регистровая машина</p>

<p class="justify-style">Компьютеры используют регистры (или аккумуляторы как частный случай) для работы с арифметико-логическими устройствами (АЛУ). Машины, которые полагаются на эту конструкцию, называются регистровыми машинами. Это потому, что при выполнении программ на таком компьютере мы фактически производим вычисления в регистрах. Если мы хотим сложить, разделить или сделать что-то еще, мы должны загрузить соответствующие данные из памяти в соответствующие регистры. Затем мы вызываем определенную инструкцию, чтобы вызвать соответствующую операцию над ними, а затем еще одну, чтобы сохранить результат из одного из регистров обратно в память.</p>

<p class="justify-style">Предположим, мы хотим написать программу, которая вычисляет выражение <code class="fs-5 fst-italic">s=x+(2*y)+z</code> на компьютере с двумя регистрами — A и B. Предположим также, что</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style">s, x, y и z — адреса памяти, в которых хранятся некоторые значения.</p>
  </li>
  <li>
    <p class="justify-style">Некоторый низкоуровневый псевдоассемблерный код с такими инструкциями, как «Загрузить», «Сложить» и «Умножить».</p>
  </li>
</ul>

<p class="justify-style">Такую теоретическую машину можно запрограммировать с помощью простой программы, представленной в <a href="#l-1-1">листинге 1-1</a>.</p>

<br>
<figure id="l-1-1" class="figure">
  <pre class="code border border-secondary">
    <code class="language-assembly">
      Load      A, y    // A = y
      Multiply  A, 2    // A = A * 2 = 2 * y
      Load      B, x    // B = x
      Add       A, B    // A = A + B = x + 2 * y
      Load      B, z    // B = z
      Add       A, B    // A = A + B = x + 2 * y + z
      Store     s, A    // s = A
    </code>
  </pre>
  <figcaption class="figure-caption">Листинг 1-1. Псевдокод примера программы, реализующей вычисление <code class="fs-5 fst-italic">s=x+(2*y)+z</code> на простой двух-регистровой машине. Комментарии показывают состояние регистра после выполнения каждой инструкции</figcaption>
</figure>

<p class="justify-style">Если этот код напоминает вам x86 или любой другой ассемблерный код, который вы когда-либо изучали, это не совпадение! Это потому, что большинство современных компьютеров — это сложные регистровые машины. Все процессоры Intel и AMD, которые мы используем в наших компьютерах, работают таким образом. При написании ассемблерного кода на базе x86/x64 мы оперируем регистрами общего назначения, такими как eax, ebx, ecx и т. д. Конечно, есть еще много инструкций, других специализированных регистров и т. д. Но концепция та же самая.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Можете ли вы представить себе машину с набором инструкций, которая позволяет выполнять операцию непосредственно в памяти без необходимости загрузки данных в регистры? Следуя псевдоассемблеру, это может выглядеть гораздо более лаконично и высокоуровнево, поскольку больше нет необходимости в инструкциях загрузки/сохранения:</p>
    <pre class="code border border-secondary">
      <code class="language-assembly">
        Multiply  s, y, 2   // s = 2 * y
        Add       s, x      // s = s + x = 2 * y + x
        Add       s, z      // s = s + z = 2 * y + x + z
      </code>
    </pre>
    <p class="card-text justify-style">Да, были такие машины, как IBM system/360, но на сегодняшний день нам не известно ни об одном серийно используемом компьютере такого типа.</p>
  </div>
</div>

<hr class="border-2">

<p id="chapter1-1-3" class="h4 p2">Стек</p>

<p class="justify-style">Концептуально стек представляет собой структуру данных, которую можно просто описать как список «последним пришел, первым ушел» (LIFO). Он позволяет выполнять две основные операции: добавлять некоторые данные наверх («push») и удалять + возвращать некоторые данные сверху («pop»), как показано на <a href="#f-1-2">рисунке 1-2</a>.</p>

<figure id="f-1-2" class="figure">
  <img src="content/img/1-2.png" class="img-fluid" alt="Рисунок 1-2" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-2. Операции извлечения и добавления стека. Это только концептуальный рисунок, не связанный с какой-либо конкретной моделью памяти и реализацией</figcaption>
</figure>

<p class="justify-style">Концепция стека стала неотъемлемо связана с программированием с самого начала, в основном из-за концепции подпрограммы. Сегодняшний .NET активно использует концепции «стек вызовов» и «стек», поэтому давайте посмотрим, как все начиналось. Первоначальное значение стека как структуры данных по-прежнему актуально (например, в .NET есть коллекция Stack&ltT&gt).</p>

<p class="justify-style">Стек является очень важным аспектом управления памятью, поскольку при программировании в .NET туда может быть помещено много наших данных. Давайте подробнее рассмотрим стек и его использование в вызовах функций. Мы будем использовать пример программы из <a href="#l-1-2">листинга 1-2</a>, написанный на псевдокоде в стиле C, который вызывает две функции – main вызывает fun1 (передавая два аргумента a и b), которая имеет две локальные переменные x и y. Затем функция fun1 в какой-то момент вызывает функцию fun2 (передавая один аргумент n), которая имеет одну локальную переменную z.</p>

<br>
<figure id="l-1-2" class="figure">
  <pre class="code border border-secondary">
    <code class="language-assembly">
      void main()
      {
        ...
        fun1(2, 3);
        ...
      }
      
      int fun1(int a, int b)
      {
        int x, y;
        ...
        fun2(a+b);
      }
      
      int fun2(int n)
      {
        int z;
        ...
      }
    </code>
  </pre>
  <figcaption class="figure-caption">Листинг 1-2. Псевдокод программы, вызывающей функцию внутри другой функции</figcaption>
</figure>

<p class="justify-style">Сначала представьте себе непрерывную область памяти, предназначенную для обработки стека, нарисованную таким образом, что последующие ячейки памяти имеют растущие адреса (см. левую часть <a href="#f-1-3a">рисунка 1-3a</a>), и вторую область памяти, где находится ваш программный код (см. правую часть <a href="#f-1-3a">рисунка 1-3a</a>), организованную таким же образом. Поскольку код функций не обязательно должен лежать рядом друг с другом, блоки кода main, fun1 и fun2 нарисованы раздельно. Выполнение программы из <a href="#l-1-2">листинга 1-2</a> можно описать следующими шагами:</p>

<br>
<ol class="ms-1 numbered-list">
  <li>
    <p class="justify-style">Прямо перед вызовом fun1 внутри main (см. <a href="#f-1-3a">рисунок 1-3a</a>). Очевидно, что поскольку программа уже запущена, некоторая область стека уже создана (серая часть в верхней части области стека на <a href="#f-1-3a">рисунке 1-3a</a>). Указатель стека (SP) хранит адрес, указывающий текущую границу стека. Счетчик программ (PC) указывает куда-то внутри функции main (мы обозначили это как адрес A1), прямо перед инструкцией вызвать fun1.</p>
  </li>
  
  <figure id="f-1-3a" class="figure">
    <img src="content/img/1-3a.png" class="img-fluid" alt="Рисунок 1-3a" max-width="600">
    <figcaption class="figure-caption">Рисунок 1-3a. Стек и области памяти кода – в момент перед вызовом функции fun1 из <a href="#l-1-2">листинга 1-2</a></figcaption>
  </figure>

  <li>
    <div>
      <p class="justify-style">После вызова fun1 внутри main (см. <a href="#f-1-3b">рис. 1-3b</a>). При вызове функции стек расширяется путем перемещения SP для хранения необходимой информации. Это дополнительное пространство включает:</p>
      <ul class="ms-1 bullet-list">
        <li>
          <p class="justify-style"><span class="fw-bold fst-italic">Аргументы:</span> Все аргументы функции могут быть сохранены в стеке. В нашем примере там были сохранены значения аргументов a (2) и b (3).</p>
        </li>
        <li>
            <p class="justify-style"><span class="fw-bold fst-italic">Адрес возврата:</span> Чтобы иметь возможность продолжить выполнение функции main после выполнения fun1, адрес следующей инструкции сразу после вызова функции сохраняется в стеке. В нашем случае мы обозначили его как адрес A1+1 (указывающий на следующую инструкцию после инструкции под адресом A1).</p>
        </li>
        <li>
            <p class="justify-style"><span class="fw-bold fst-italic">Локальные переменные:</span> Место для всех локальных переменных, которые также могут быть сохранены в стеке. В нашем примере там были сохранены переменные x и y.</p>
        </li>
      </ul>
      <p class="justify-style">Структура, помещаемая в стек при вызове подпрограммы, называется <span class="fw-bold fst-italic">кадром активации</span>. В типичной реализации указатель стека уменьшается на соответствующее смещение, чтобы указать место, где может начаться новый кадр активации. Поэтому часто говорят, что стек растет вниз.</p>
    </div>
  </li>
    
  <figure id="f-1-3b" class="figure">
    <img src="content/img/1-3b.png" class="img-fluid" alt="Рисунок 1-3b" max-width="600">
    <figcaption class="figure-caption">Рисунок 1-3b. Стек и области памяти кода – после вызова функции fun1 из <a href="#l-1-2">листинга 1-2</a></figcaption>
  </figure>

  <li>
    <p class="justify-style">После вызова fun2 из fun1 (см. <a href="#f-1-3c">рис. 1-3c</a>). Повторяется та же схема создания нового кадра активации. На этот раз он содержит область памяти для значения аргумента n, адрес возврата A2+1 и локальную переменную z.</p>
  </li>
      
  <figure id="f-1-3c" class="figure">
    <img src="content/img/1-3c.png" class="img-fluid" alt="Рисунок 1-3c" max-width="600">
    <figcaption class="figure-caption">Рисунок 1-3c. Стек и области памяти кода – в момент после вызова функции fun2 из fun1</figcaption>
  </figure>

</ol>

<p class="justify-style">Кадр активации также называется более общим термином <span class="fw-bold fst-italic">кадр стека</span>, что означает любые структурированные данные, сохраненные в стеке для конкретных целей.</p>

<p class="justify-style">Как вы можете себе представить, последующие вызовы вложенных подпрограмм просто повторяют этот шаблон, добавляя один кадр активации для каждого вызова. Чем больше вложенных вызовов подпрограмм, тем больше кадров активации будет в стеке. Это, конечно, делает вызов бесконечных вложенных вызовов невозможным, так как это потребовало бы памяти для бесконечного числа кадров <a class="fw-bolder" data-bs-toggle="modal" data-bs-target="#TailCalls">активации</a>. В .NET такой бесконечный цикл заканчивается исключением <span class="fw-bold fst-italic">StackOverflowException</span>. Вы вызвали так много вложенных подпрограмм, что достигли предела памяти для стека.</p>

<p class="justify-style">Имейте в виду, что представленный здесь механизм является всего лишь примерным и очень общим. Фактические реализации могут различаться в зависимости от архитектуры и операционной системы. Мы подробно рассмотрим, как кадры активации и стек используются .NET в последующих главах.</p>

<p class="justify-style">Когда подпрограмма завершается, ее кадр активации просто отбрасывается путем увеличения указателя стека на размер текущего кадра активации, в то время как сохраненный адрес возврата используется для перехода выполнения обратно к вызывающей функции. Другими словами, то, что было внутри кадра стека (локальные переменные, параметры), больше не нужно, поэтому увеличения указателя стека достаточно, чтобы «освободить» память, использованную до сих пор. Эти данные будут просто перезаписаны при следующем использовании стека другими вызовами функций (см. <a href="#f-1-4">рисунок 1-4</a>).</p>

<figure id="f-1-4" class="figure">
  <img src="content/img/1-4.png" class="img-fluid" alt="Рисунок 1-4" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-4. Stack and code memory regions – after returning from function fun1, both activation frames are discarded</figcaption>
</figure>

<p class="justify-style">Что касается реализации, то и SP, и PC обычно хранятся в выделенных регистрах. На этом этапе размер самого адреса, наблюдаемые области памяти и регистры не особенно важны.</p>

<p class="justify-style">Стек в современных компьютерах поддерживается как аппаратным обеспечением (путем предоставления специальных регистров для указателей стека), так и программным обеспечением (путем абстракции операционной системы от потока и его части памяти, обозначенной как стек).</p>

<hr class="border-2">

<p id="chapter1-1-4" class="h4 p2">Стековая машина</p>

<p class="justify-style">Прежде чем перейти к другим концепциям памяти, давайте на некоторое время остановимся на контексте, связанном со стеком, — так называемых <span class="fw-bold fst-italic">стековых машинах</span>. В отличие от регистровой машины, все инструкции в стековой машине работают с выделенным <span class="fw-bold fst-italic">стеком выражений</span> (или <span class="fw-bold fst-italic">стеком вычислений</span>). Пожалуйста, имейте в виду, что этот стек не обязательно должен быть тем же стеком, о котором мы говорили ранее. Следовательно, такая машина может иметь как дополнительный «<span class="fw-bold fst-italic">стек выражений</span>», так и стек общего назначения. Регистров может вообще не быть. В такой машине по умолчанию инструкции берут аргументы с вершины стека выражений — столько, сколько им требуется. Результат также сохраняется на вершине стека. В таких случаях они называются <span class="fw-bold fst-italic">чистыми стековыми машинами</span>, в отличие от нечистых реализаций, когда операции могут получать доступ к значениям не только с вершины стека, но и глубже.</p>

<p class="justify-style">Как именно выглядит операция в стеке выражений? Например, гипотетическая инструкция Multiply (без аргументов) извлечет два значения из верхней части стека оценки для своих параметров, умножит их и поместит результат обратно в стек оценки (см. <a href="#f-1-5">рисунок 1-5</a>).</p>

<figure id="f-1-5" class="figure">
  <img src="content/img/1-5.png" class="img-fluid" alt="Рисунок 1-5" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-5. Гипотетическая инструкция умножения в стековой машине — извлекает два элемента из стека и помещает результат их умножения в стек.</figcaption>
</figure>

<p class="justify-style">Давайте вернемся к образцу выражения <code class="fs-5 fst-italic">s=x+(2*y)+z</code> из примера регистровой машины и перепишем его в стиле стековой машины (см. <a href="#l-1-3">листинг 1-3</a>).</p>

<br>
<figure id="l-1-3" class="figure">
  <pre class="code border border-secondary">
    <code class="language-assembly">
                  // empty stack
      Push 2      // [2] - single stack element of value 2       
      Push y      // [2][y] - two stack elements of value 2 and y        
      Multiply    // [2*y]        
      Push x      // [2*y][x]        
      Add         // [2*y+x]        
      Push z      // [2*y+x][z]        
      Add         // [2*y+x+z]        
      Pop l       // [] (with side effect of writing a value into l)        
    </code>
  </pre>
  <figcaption class="figure-caption">Листинг 1-3. Пример программы, реализующей вычисление <code class="fs-6 fst-italic">s=x+(2*y)+z</code> на простой двух-регистровой машине, переписанный в стиле стековой машины</figcaption>
</figure>

<p class="justify-style">Эта концепция приводит к очень ясному и понятному коду. Основные преимущества можно описать следующим образом:</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style">Нет никаких проблем относительно того, как и где хранить временные значения – должны ли они быть регистрами, стеком или основной памятью. Концептуально это проще, чем пытаться оптимально управлять всеми этими возможными целями. Таким образом, это упрощает реализацию.</p>
  </li>
  <li>
    <p class="justify-style">Опкоды могут быть короче с точки зрения требуемой памяти, поскольку существует много инструкций без операндов или с одним операндом. Это позволяет эффективно кодировать инструкции в двоичном формате и, следовательно, производить плотный двоичный код. Несмотря на необходимость большего количества операций загрузки/сохранения, что может увеличить количество инструкций по сравнению с подходом на основе реестра, этот метод остается полезным.</p>
  </li>
</ul>

<p class="justify-style">Это было важным преимуществом в ранние времена компьютеров, когда память была очень дорогой и ограниченной. Это может быть выгодно и сегодня в случае загружаемого кода для смартфонов или веб-приложений. Плотное двоичное кодирование инструкций также подразумевает лучшее использование кэша ЦП.</p>

<p class="justify-style">Несмотря на свои преимущества, концепция стековой машины редко реализовывалась в самом оборудовании. Одним заметным исключением были машины Burroughs, такие как B5000, которые включали аппаратную реализацию стека. В настоящее время, вероятно, нет широко используемой машины, которую можно было бы описать как стековую машину. Одним заметным исключением является блок с плавающей точкой x87 (внутри x86-совместимых процессоров): он был разработан как стековая машина и до сих пор программируется как таковая из-за обратной совместимости.</p>

<p class="justify-style">Так зачем вообще упоминать эти типы машин? Потому что такая архитектура — отличный способ проектирования независимых от платформы виртуальных машин или механизмов выполнения. Виртуальная машина Java и среда выполнения .NET — прекрасные примеры стековых машин. Они реализованы поверх архитектуры x86 или ARM, которые являются хорошо известными регистровыми машинами, но это не меняет того факта, что они реализуют логику стековой машины. Мы наглядно покажем это при описании промежуточного языка (IL) .NET в Главе 4. Почему среда выполнения .NET и JVM (виртуальная машина Java) были спроектированы таким образом? Как всегда, это смесь инженерных и исторических причин. Код стековой машины лучше подходит для абстрагирования от базового оборудования, поскольку он не зависит от количества доступных регистров. Затем задача перевода кода стековой машины в фактический код на основе регистров остается за конкретной реализацией для целевого оборудования. Виртуальные стековые машины проще реализовать и обеспечивают хорошую независимость от платформы, при этом по-прежнему производя высокопроизводительный код. В сочетании с упомянутой лучшей плотностью кода это хороший выбор для платформы, которая должна работать на широком спектре устройств. Вероятно, именно поэтому Sun решила выбрать этот путь, когда Java была изобретена для небольших устройств, таких как телевизионные приставки. Microsoft, разрабатывая .NET, также следовала этому пути. Концепция стековой машины элегантна и проста, и она просто работает. Это делает реализацию виртуальной машины более приятной инженерной задачей!</p>

<p class="justify-style">С другой стороны, проекты виртуальных машин на основе реестра гораздо ближе к проекту реального оборудования, на котором они работают. Это очень полезно с точки зрения возможных оптимизаций. Сторонники этого подхода говорят, что можно достичь гораздо лучшей производительности, особенно в интерпретируемых средах выполнения. У интерпретатора ограниченное время для применения расширенных оптимизаций, поэтому чем ближе интерпретируемый код к машинному коду, тем он лучше. Кроме того, работа с наиболее часто используемым набором регистров обеспечивает большую <a class="fw-bolder" data-bs-toggle="modal" data-bs-target="#CacheLocality">локальность кэша</a>.</p>

<p class="justify-style">Как всегда, принимая решение, вам нужно идти на некоторые компромиссы. Спор между сторонниками обоих подходов длится долго и неразрешен. Тем не менее, факт в том, что в настоящее время механизм выполнения .NET реализован как стековая машина, хотя она и не полностью чистая — как показано в Главе 4. Вы также увидите, как стек оценки сопоставляется с базовым оборудованием, состоящим из регистров и памяти.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Все ли виртуальные машины и движки выполнения являются стековыми машинами? Абсолютно нет! Одним из заметных исключений является Dalvik, который был виртуальной машиной в Android от Google до версии 4.4, которая была реализацией JVM на основе реестра. Это был интерпретатор промежуточного «байт-кода Dalvik». Но затем в преемнике Dalvik — Android Runtime (ART) была введена технология JiT (Just-in-Time-компиляция, описанная в главе 4). Другие примеры включают BEAM (виртуальная машина для Erlang/Elixir), Chakra (движок выполнения Javascript в iE9), Parrot (виртуальная машина Perl 6) и Lua VM (виртуальная машина Lua). Поэтому никто не может сказать, что этот тип машин не популярен.</p>
  </div>
</div>

<hr class="border-2">
<p id="chapter1-1-5" class="h4 p2">Указатель</p>

<p class="justify-style">До сих пор мы представили только две концепции памяти: статическое распределение и распределение стека (как часть стекового фрейма). Концепция <span class="fw-bold fst-italic">указателя</span> является очень общей и может быть обнаружена с самого начала вычислительной эры – как ранее показанная концепция указателя инструкций (счетчика программ) или указателя стека. Конкретные регистры, предназначенные для адресации памяти, такие как <a class="fw-bolder" data-bs-toggle="modal" data-bs-target="#IndexRegisters">индексные регистры</a>, также могут рассматриваться как указатели.</p>

<p class="justify-style">Указатели — это переменные, в которых вы храните адрес позиции в памяти. Проще говоря, это позволяет вам ссылаться на другие места в памяти по его адресу. Размер указателя связан с длиной слова, упомянутой ранее, и зависит от архитектуры компьютера. В настоящее время мы обычно имеем дело с указателями шириной 32 или 64 бита, размещенными в стеке (например, как локальная переменная или аргумент функции) или в регистрах ЦП. На <a href="#f-1-6">рисунке 1-6</a> показана типичная ситуация, когда одна из локальных переменных (хранящихся в кадре активации функции) является указателем на другую область памяти с адресом Addr.</p>

<figure id="f-1-6" class="figure">
  <img src="content/img/1-6.png" class="img-fluid" alt="Рисунок 1-6" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-6. Локальная переменная ptr функции, являющаяся указателем на память по адресу Addr</figcaption>
</figure>

<p class="justify-style">Простая идея указателей позволяет нам создавать сложные структуры данных, такие как связанные списки или деревья, поскольку структуры данных в памяти могут ссылаться друг на друга, создавая более сложные структуры (см. <a href="#f-1-7">рисунок 1-7</a>).</p>

<figure id="f-1-7" class="figure">
  <img src="content/img/1-7.png" class="img-fluid" alt="Рисунок 1-7" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-7. Указатели, используемые для построения двусвязной структуры списка, когда каждый элемент указывает на свой предыдущий и следующий элементы.</figcaption>
</figure>

<hr class="border-2">

<p id="chapter1-1-6" class="h4 p2">Куча</p>

<p class="justify-style">Наконец, мы дошли до самой важной концепции в контексте управления памятью .NET. <span class="fw-bold fst-italic">Куча</span> (реже известная как <span class="fw-bold fst-italic">свободное хранилище</span>) — это область памяти, используемая для динамически выделяемых объектов. Свободное хранилище — лучшее название, поскольку оно не предполагает никакой внутренней структуры, а скорее цели. На самом деле, вы можете справедливо спросить, какова связь между структурой данных кучи и самой кучей. Правда в том, что ее нет. Хотя стек хорошо организован (он основан на концепции структуры данных LIFO), куча больше похожа на «черный ящик», который можно попросить предоставить память, независимо от того, откуда она будет поступать. Поэтому «пул» или упомянутое «свободное хранилище», вероятно, было бы лучшим названием. Название кучи, вероятно, использовалось с самого начала в традиционном английском смысле, означающем «беспорядочное место» — в отличие от хорошо упорядоченного пространства стека. Исторически выделение кучи было введено в ALGOL 68, но этот стандарт не получил широкого распространения. Но именно отсюда, вероятно, и произошло название. Факт в том, что истинное историческое происхождение этого названия сейчас довольно неясно.</p>

<p class="justify-style">Куча — это механизм, способный предоставить непрерывный блок памяти с указанным размером. Эта операция называется динамическим выделением памяти, поскольку и размер, и фактическое местоположение блока памяти не обязательно должны быть известны во время компиляции. Поскольку местоположение памяти неизвестно во время компиляции, на динамически выделенную память должен ссылаться указатель. Следовательно, концепции указателя и кучи по своей сути связаны.</p>

<p class="justify-style">Адрес, возвращаемый некоторой функцией «выделите мне X байт памяти», очевидно, следует запомнить в некотором указателе для будущей ссылки на созданный блок памяти. Он может храниться в стеке (см. <a href="#f-1-8">рисунок 1-8</a>), в самой куче или где-нибудь еще, например, в регистре.</p>

<figure id="f-1-8" class="figure">
  <img src="content/img/1-8.png" class="img-fluid" alt="Рисунок 1-8" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-8. Стек с указателем ptr и блоком шириной 10 байт в куче</figcaption>
</figure>

<p class="justify-style">Обратная операция выделения называется <span class="fw-bold fst-italic">освобождением</span>, когда заданный блок памяти возвращается в пул памяти для будущего использования. Как именно куча выделяет блок заданного размера — это деталь реализации. Существует много возможных «распределителей», и вы скоро увидите некоторые из них.</p>

<p class="justify-style">Выделяя и освобождая много блоков, мы можем прийти к ситуации, когда для данного объекта не будет достаточно непрерывного свободного пространства, хотя в целом в куче достаточно свободного места. Такая ситуация называется <span class="fw-bold fst-italic">фрагментацией</span> кучи и может привести к значительной неэффективности использования памяти. <a href="#f-1-9">Рисунок 1-9</a> иллюстрирует такую ​​проблему, когда для объекта X недостаточно свободного непрерывного пространства. Существует много различных стратегий, используемых распределителями для максимально оптимального управления пространством, чтобы избежать фрагментации (или эффективно ее использовать).</p>

<figure id="f-1-9" class="figure">
  <img src="content/img/1-9.png" class="img-fluid" alt="Рисунок 1-9" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-9. Фрагментация – после удаления объектов B и D не остается достаточного смежного пространства для нового объекта X, хотя в целом для него достаточно свободного места.</figcaption>
</figure>

<p class="justify-style">Стоит также отметить, что наличие одной кучи или нескольких экземпляров кучи в одном процессе — это еще одна деталь реализации (мы обсудим это более подробно для .NET).</p>

<p class="justify-style">Давайте сделаем краткий обзор различий между стеком и кучей в <a href="#t-1-1">Таблице 1-1</a>.</p>

<figure id="t-1-1" class="figure">
  <table class="table table-striped table-hover">
    <thead>
      <tr>
        <th scope="col">#</th>
        <th scope="col">Свойство</th>
        <th Scope="col">Стек</th>
        <th Scope="col">Куча</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">1</th>
        <td>Продолжительность жизни</td>
        <td>Область действия функции для локальных переменных (вставлено при входе, извлечено при выходе)</td>
        <td>Явное (по выделению и необязательному освобождению)</td>
      </tr>
      <tr>
        <th scope="row">2</th>
        <td>Объем</td>
        <td>Локальный (<a class="fw-bolder" data-bs-toggle="modal" data-bs-target="#LocalThread">поток</a>)</td>
        <td>Глобальный (любой, у кого есть указатель)</td>
      </tr>
      <tr>
        <th scope="row">3</th>
        <td>Доступ</td>
        <td>Локальная переменная, аргументы функции</td>
        <td>Указатель</td>
      </tr>
      <tr>
        <th scope="row">4</th>
        <td>Время доступа</td>
        <td>Быстро (часто используемая область памяти, поэтому, вероятно, кэшируется в ЦП)</td>
        <td>Медленнее (может даже временно сохраняться на жестком диске)</td>
      </tr>
      <tr>
        <th scope="row">5</th>
        <td>Распределение</td>
        <td>Перемещаемый указатель стека</td>
        <td>Различные возможные стратегии</td>
      </tr>
      <tr>
        <th scope="row">6</th>
        <td>Время распределения</td>
        <td>Очень быстро (увеличение указателя стека)</td>
        <td>Медленнее (зависит от стратегии распределения)</td>
      </tr>
      <tr>
        <th scope="row">7</th>
        <td>Освобождение</td>
        <td>Перемещаемый указатель стека</td>
        <td>Различные возможные стратегии</td>
      </tr>
      <tr>
        <th scope="row">8</th>
        <td>Использование</td>
        <td>Параметры подпрограммы, локальные переменные, кадры активации, небольшие массивы фиксированного размера</td>
        <td>Все</td>
      </tr>
      <tr>
        <th scope="row">9</th>
        <td>Емкость</td>
        <td>Ограничено (обычно несколько МБ на поток)</td>
        <td>Практически неограниченно (в пределах ГБ + доступное место на жестком диске и в зависимости от настроек операционной системы). Максимум 4 ГБ для 32 бит</td>
      </tr>
      <tr>
        <th scope="row">10</th>
        <td>Размер переменной</td>
        <td>Нет</td>
        <td><a class="fw-bolder" data-bs-toggle="modal" data-bs-target="#VariableSize">Да</a></td>
      </tr>
      <tr>
        <th scope="row">11</th>
        <td>Фрагментация</td>
        <td>Нет</td>
        <td>Скорее всего</td>
      </tr>
      <tr>
        <th scope="row">12</th>
        <td>Основные риски</td>
        <td>Переполнение стека</td>
        <td>Утечка памяти (забывание освободить выделенную память), фрагментация</td>
      </tr>
    </tbody>
  </table>
  <figcaption class="figure-caption">Таблица 1-1. Сравнение характеристик стека и кучи</figcaption>
</figure>

<p class="justify-style">Теперь давайте перейдем к обсуждению ручного и автоматического управления памятью.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Как писали Эллис и Страуструп в <cite title="Source Title">Аннотированном справочном руководстве по C++:</cite></div>
  <div class="card-body">
    <p class="card-text">Программисты на C считают, что управление памятью слишком важно, чтобы доверять его компьютеру.</p>
    <p class="card-text">Программисты на Lisp считают, что управление памятью слишком важно, чтобы доверять его пользователю.</p>
  </div>
</div>

<br>

<hr class="border-2">

<p id="chapter1-2" class="h3 p-2">Ручное управление памятью</p>

<p class="justify-style">До сих пор рассматривалось только «ручное управление памятью»: разработчик отвечает за явное выделение памяти, а затем, когда она больше не нужна, он должен ее освободить. Это настоящая ручная работа. Это в точности как ручная коробка передач в большинстве европейских автомобилей. Люди, которые привыкли вручную переключать передачи, решают, стоит ли переключать сейчас или подождать несколько секунд, пока обороты двигателя не станут достаточно высокими. У этого есть одно большое преимущество: полный контроль над автомобилем. Водитель отвечает за то, оптимально ли используется двигатель или нет. И поскольку люди все еще гораздо более адаптивны к изменяющимся условиям, хорошие водители справятся с этой задачей лучше, чем автоматическая коробка передач. Конечно, есть один большой недостаток. Вместо того чтобы думать о нашей главной цели — добраться из пункта А в пункт Б — приходится дополнительно думать о переключении передач — сотни или тысячи раз за длительную поездку. Это и времязатратно, и утомительно. Некоторые скажут, что это весело, и посчитают скучным отдавать этот контроль автоматической коробке передач. Нам очень нравится, как эта автомобильная метафора соотносится с управлением памятью.</p>

<p class="justify-style">Когда мы говорим о явном выделении и освобождении памяти, это то же самое, что иметь ручную передачу. Вместо того, чтобы думать о своей главной цели, которая, вероятно, связана с бизнес-обработкой, вы также должны думать о том, как управлять памятью в вашей программе. Это отвлекает вас от главных целей и требует дополнительных усилий. Вместо того, чтобы думать об алгоритмах, бизнес-логике и доменах, вы также должны думать о том, сколько памяти понадобится и как долго. И какая часть кода будет отвечать за ее освобождение? Похоже ли это на бизнес-логику? Конечно, нет. Вопрос о том, хорошо это или нет, — это уже другая история.</p>

<p class="justify-style">Известный язык C был разработан Деннисом Ритчи примерно в начале 1970-х годов и стал одним из самых широко используемых языков программирования в мире. История того, как C эволюционировал из ALGOL через промежуточные языки, такие как CPL, BCPL и B, интересна сама по себе. Вместе с Pascal (будучи прямым предком ALGOL), они были двумя самыми популярными языками с явным управлением памятью в то время. Без сомнения, компилятор C был написан для каждой когда-либо созданной аппаратной архитектуры. Мы не удивились бы, если бы инопланетные космические корабли имели свой собственный компилятор C на борту (вероятно, реализующий стек TCP/IP как пример другого широко используемого стандарта). Влияние этого языка на другие языки программирования огромно, и его нельзя недооценивать. Давайте остановимся на мгновение и более подробно рассмотрим его в контексте управления памятью. Это позволит нам перечислить некоторые характеристики ручного управления памятью.</p>

<p class="justify-style">Давайте рассмотрим простой пример кода, написанного на языке C в <a href="#l-1-4">листинге 1-4</a>.</p>

<br>
<figure id="l-1-4" class="figure">
  <pre class="code border border-secondary">
    <code class="language-c">
      #include &lt;stdio.h&gt;
      void printReport(int* data)
      {
        printf("Report: %d\n", *data);
      }
      int main(void)
      {
        int* ptr;
        ptr = (int*)malloc(sizeof(int));
        if (ptr == NULL)
        {
          printf("ERROR: Out of memory\n");
          return 1;
        }
        *ptr = 25;
        printReport(ptr);
        free(ptr);
        ptr = NULL;
        return 0;
      }
    </code>
  </pre>
  <figcaption class="figure-caption">Листинг 1-4. Пример программы на языке C, демонстрирующей ручное управление памятью</figcaption>
</figure>

<p class="justify-style">Это, конечно, немного преувеличенный пример, но он поможет проиллюстрировать проблему ручного управления памятью. Вы можете заметить, что этот простой код на самом деле имеет только одну простую бизнес-цель: печать «отчета». Для простоты этот отчет состоит только из одного целого числа, но вы можете представить его как более сложную структуру, содержащую указатели на другие структуры данных и так далее. Эта простая бизнес-цель выглядит перегруженной большим количеством «церемониального кода», который заботится только о памяти. Это ручное управление памятью по своей сути.</p>

<p class="justify-style">Подводя итог предыдущему фрагменту кода, помимо деловой логики написания, разработчик должен</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style">Выделить необходимый объем памяти для необходимых данных с помощью функции malloc.</p>
  </li>
  <li>
    <p class="justify-style">Привести возвращаемый универсальный указатель (void*) к соответствующему типу указателя (int*), чтобы указать, что он указывает на числовое значение (в данном случае тип int).</p>
  </li>
  <li>
    <p class="justify-style">Отслеживать указатель на выделенную область памяти в локальной переменной указателя ptr.</p>
  </li>
  <li>
    <p class="justify-style">Проверить, был ли успешно выделен запрошенный объем памяти (т. е. возвращенный адрес будет равен 0 в случае неудачи — обратите внимание, что константа NULL используется для лучшей читаемости кода).</p>
  </li>
  <li>
    <p class="justify-style">Разыменовать указатель (получить доступ к памяти, указанной по его адресу) для сохранения некоторых данных (числовое значение 25).</p>
  </li>
  <li>
    <p class="justify-style">Передать указатель другой функции, printReport, которая разыменует его для своих собственных целей.</p>
  </li>
  <li>
    <p class="justify-style">Освободить выделенную память, когда она больше не нужна, с помощью функции free.</p>
  </li>
  <li>
    <p class="justify-style">Чтобы гарантировать, что указатель больше не будет использоваться, его значению присваивается специальное значение <a class="fw-bolder" data-bs-toggle="modal" data-bs-target="#NullPointer">NULL</a>: это способ сообщить, что указатель никуда не указывает и фактически соответствует значению 0.</p>
  </li>
</ul>

<p class="justify-style">Как видите, разработчик должен помнить о многом, когда вручную управляет памятью. Более того, каждый из предыдущих шагов может быть ошибочно использован или забыт, что может привести к целому ряду серьезных проблем. Пройдясь по каждому из этих шагов, давайте посмотрим, какие плохие вещи могут произойти:</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style">Необходимо знать точный объем необходимой памяти. Это так же просто, как вызвать sizeof(int) в нашем примере, но что, если нужна гораздо более сложная, вложенная структура данных? Могут произойти два типа ошибок. Одна из них может выделить слишком много памяти, что может привести к снижению производительности или утечкам памяти. Или одна может выделить слишком мало памяти, что заставит программу писать за пределами границ области памяти, ошибка, обычно известная как <span class="fw-bolder fst-italic">переполнение буфера</span>. В лучшем случае это приведет к ошибке <span class="fw-bolder fst-italic">сегментации</span> в Linux или <span class="fw-bolder fst-italic">нарушению доступа</span> в Windows, но в худшем случае это может привести к повреждению данных или уязвимостям безопасности.</p>
  </li>
  <li>
    <p class="justify-style">Приведение типов всегда подвержено ошибкам и может привести к трудно диагностируемым ошибкам, если случайно возникнет несоответствие типов. Вы попытаетесь интерпретировать указатель некоторого типа так, как будто это совершенно другой тип, что легко приведет к фатальным нарушениям доступа.</p>
  </li>
  <li>
    <p class="justify-style">Одна проверка того, смогли ли мы выделить желаемый объем памяти, не обременительна. Но делать это сто раз в каждой функции наверняка будет обременительно. Вы, вероятно, решите пропустить эти проверки, но это может привести к неопределенному поведению во многих точках приложения, пытаясь получить доступ к памяти, которая изначально не была успешно выделена.</p>
  </li>
  <li>
    <p class="justify-style">Разыменование указателей всегда опасно. Никто никогда не знает, что находится по адресу, на который указывает. Есть ли еще действительный объект или, может быть, он уже освобожден? Действителен ли этот указатель изначально? Указывает ли он на правильное место в памяти? Полный контроль над указателем в языках вроде C приводит к таким беспокойствам. Ручной контроль над указателями приводит к серьезным проблемам безопасности — недоступность недействительных областей памяти остается исключительной ответственностью программиста. Передача указателя между функциями и потоками только увеличивает беспокойства на другой порядок по сравнению с предыдущими пунктами в многопоточной среде.</p>
  </li>
  <li>
    <p class="justify-style">Вы должны помнить об освобождении выделенной памяти. Если вы пропустите этот шаг, вы вызовете утечку памяти. В таком простом примере, как предыдущий, конечно, маловероятно, что вы забудете вызвать функцию free. Но это гораздо более проблематично в более сложных кодовых базах, когда владение структурами данных не столь очевидно и где указатели на эти структуры передаются тут и там. Есть и еще один риск — никто не может помешать вам освободить память, которая уже была освобождена. Тем не менее, это еще один повод для неопределенного поведения и вероятная причина нарушения доступа/ошибки сегментации.</p>
  </li>
  <li>
    <p class="justify-style">И последнее, но не менее важное: вы всегда должны помечать свои указатели как NULL, чтобы указать, что они больше не указывают на допустимый объект. В противном случае это называется висячим указателем, который рано или поздно может привести к сбою приложения, поскольку он разыменовывается другой частью кода, которая считает, что он все еще представляет допустимые данные.</p>
  </li>
</ul>

<p class="justify-style">С точки зрения разработчика, явное выделение и освобождение памяти может стать очень обременительным. Это очень мощная функция, которая, несомненно, имеет свои идеальные приложения. Когда важна экстремальная производительность и разработчик должен иметь полный контроль над происходящим, этот подход может оказаться полезным. Но «с большой силой приходит большая ответственность», так что это палка о двух концах. По мере развития разработки программного обеспечения языки становятся все более совершенными и предоставляют более совершенные инструменты, помогающие разработчикам управлять памятью.</p>

<p class="justify-style">Идя дальше, прямой преемник языка C, C++, пытается немного улучшить ситуацию. Предыдущий пример транслируется на C++, как показано в <a href="#l-1-5">листинге 1-5</a>.</p>

<br>
<figure id="l-1-5" class="figure">
  <pre class="code border border-secondary">
    <code class="language-cpp">
      #include &lt;iostream&gt;
      void printReport(int* data)
      {
        std::cout &lt;&lt; "Report: " &lt;&lt; *data &lt;&lt; "\n";
      }
      int main()
      {
        try
        {
          int* ptr;
          ptr = new int();
          *ptr = 25;
          printReport(ptr);
          delete ptr;
          ptr = NULL;
          return 0;
        }
        catch (std::bad_alloc& ba)
        {
          std::cout &lt;&lt; "ERROR: Out of memory\n";
          return 1;
        }
      }
    </code>
  </pre>
  <figcaption class="figure-caption">Листинг 1-5. Пример программы на C++, демонстрирующей ручное управление памятью</figcaption>
</figure>

<p class="justify-style">Вы можете заметить некоторые существенные улучшения:</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style">Оператор new заботится о выделении достаточного количества памяти, зная, сколько ему необходимо, благодаря поддержке компилятора (который предполагает правильный размер типа).</p>
  </li>
  <li>
    <p class="justify-style">Больше нет необходимости приводить полученный указатель к соответствующему типу. Это устраняет некоторые проблемы безопасности типов, рассмотренные ранее.</p>
  </li>
  <li>
    <p class="justify-style">Обработка ошибок выделения памяти также улучшена за счет использования исключений.</p>
  </li>
</ul>

<p class="justify-style">Тем не менее, в этом примере требуется много церемониального кода. Также вводится новая проблема. Что, если функция printReport() выдаст исключение? Без надлежащей обработки ошибок вызов оператора удаления может быть легко пропущен, что приведет к утечке памяти. Исправление кода примера легко, но это может быть не столь очевидно в более сложных приложениях, поскольку владение данными (кто и на каком уровне должен удалять такие указатели) может быть нетривиальным.</p>

<p class="justify-style">Все проблемы, которые вы видели в этой главе, усугубляются в многопоточных средах, где указатели могут совместно использоваться несколькими единицами выполнения. Необходимо тщательно продумать синхронизацию, чтобы избежать смешивания недействительных данных. Например, что, если один поток проверяет, является ли данный указатель действительным (не NULL), а другой сразу после этого освобождает указанную память? Такие ситуации могут приводить к периодическим и очень трудно диагностируемым проблемам. В мире явного управления памятью разработчик должен предоставить подходящий механизм синхронизации, чтобы избежать таких ситуаций.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Пример C++, представленный в листинге 1-5, намеренно не соответствует текущим моделям использования памяти в этом языке. Он должен использовать своего рода технику RAii (Resource Acquisition is initialization), где ресурс (например, память) представлен локальной переменной типа, реализующей некоторую логику владения памятью. Пример такого будет представлен позже в <a href="#l-1-9">листинге 1-9</a>. Хотя, как вы увидите, такие модели помогают решить некоторые проблемы, они не сильно меняют общее обсуждение ручного и автоматического управления памятью.</p>
  </div>
</div>

<hr class="border-2">

<p id="chapter1-3" class="h3 p-2">Автоматическое управление памятью</p>

<p class="justify-style">Чтобы преодолеть проблемы ручного управления памятью и предоставить программисту более удобный способ решения этой проблемы, были предложены различные подходы к автоматическому управлению памятью. Интересно знать, что второй старейший язык программирования высокого уровня — LISP — созданный в 1958 году (всего через несколько лет после FORTRAN), мог многое предложить в этой области. Интересный анекдот рассказывает Джон Маккарти в статье о проектировании LISP «Рекурсивные функции символических выражений и их машинное вычисление, часть I». Он кратко описал этот механизм, но назвал его просто «рекламация». Позже он прокомментировал эту часть:</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Цитата</div>
  <div class="card-body">
    <p class="card-text justify-style">Мы уже называли этот процесс «сборкой мусора», но, видимо, я постеснялся использовать его в статье — иначе мне не разрешили бы грамотеи из Научно-исследовательской лаборатории электроники.</p>
  </div>
</div>

<p class="justify-style">Помимо названия, идея была готова к реализации. В настоящее время названия механизма автоматического управления памятью и <span class="fw-bolder fst-italic">сборки мусора</span> используются как взаимозаменяемые. Мы можем определить его как механизм, который снимает с программиста ответственность за ручное управление памятью, так что однажды созданные объекты автоматически уничтожаются (а память после них восстанавливается), когда они больше не нужны.</p>

<p class="justify-style">Одно из главных сообщений, которое мы хотели бы донести в этой книге, заключается в том, что даже когда управление памятью полностью автоматизировано, оно может вызывать проблемы. В качестве небольшого подтверждения стоит привести забавный факт, касающийся первой реализации сборки мусора в LISP. Как вспоминает Маккарти в книге <span class="fw-bolder fst-italic">History of Programming Languages I</span>, во время самой первой публичной демонстрации LISP на одном из симпозиумов по связям с промышленностью Массачусетского технологического института из-за незначительной оплошности Flexowriter (электрическая пишущая машинка того времени) начал печатать много страниц с сообщением об ошибке, начинающимся с</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Цитата</div>
  <div class="card-body">
    <p class="card-text justify-style fst-italic blockquote">THE GARBAGE COLLECTOR HAS BEEN CALLED. SOME INTERESTING STATISTICS ARE AS FOLLOWS</p>
    <p class="card-text justify-style blockquote-footer">вызван сборщик мусора. некоторые интересные статистические данные видны ниже</p>
  </div>
</div>

<p class="justify-style">Из-за этого презентацию пришлось отменить, пока зрители смеялись от души. Никто, кроме самого Джона, не знает, было ли это следствием неправильного использования сборщика мусора. И хотя это была человеческая, а не алгоритмическая ошибка, можно сказать, что сборщики мусора с самого начала создали проблемы!</p>

<hr class="border-2">

<p id="chapter1-3-1" class="h4 p2">Аллокатор, мутатор и сборщик</p>

<p class="justify-style">Мутаторы и другие концепции являются важными терминами в академических исследованиях автоматического управления памятью. Благодаря четким определениям вы сможете различать их позже в академических и технических работах без двусмысленности. Можно сказать, например, о «накладных расходах на Мутатор» определенных алгоритмов. При рассмотрении различных конструкций сборки мусора часто будет возникать дискуссия о влиянии Сборщика на Мутатор и наоборот. Давайте подробнее рассмотрим эти термины.</p>

<p class="h5 p2 fw-bold">Мутатор</p>

<p class="justify-style">Среди нескольких основных понятий, связанных с управлением памятью, наиболее базовым, но важным является абстракция, называемая Мутатором. В своей простейшей версии Мутатор можно определить как сущность, ответственную за выполнение кода приложения. Его название происходит от того факта, что Мутатор изменяет (мутирует) состояние памяти — объекты выделяются или изменяются, а ссылки между ними изменяются. Другими словами, Мутатор — это движущая машина всех изменений в приложении относительно памяти. Это название было придумано (среди прочих, в той же статье) Эдсгером Дейкстрой в 1978 году в статье «Сборка мусора на лету: упражнение в сотрудничестве», где мы можем найти подробную разработку по этой теме. Интересным побочным фактом является то, что предложение Дейкстры из этой довольно старой статьи все еще используется, например, языком Go в 2015 году, и с хорошими результатами.</p>

<p class="justify-style">Абстракция Мутатор обеспечивает красивую и ясную категоризацию вещей внутри определенного фреймворка или среды выполнения. Вы можете определить Мутатор как все, что может изменять память, либо обновляя существующие объекты, либо создавая новые. Хотя это не строго, мы можем расширить его на все, что может читать память (поскольку чтение является важнейшей операцией для выполнения программы). Это приводит к важному наблюдению — чтобы быть полностью работоспособным, Мутатор должен предоставить три операции работающему приложению:</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style">New(amount): Выделяет заданный объем памяти, который затем будет использоваться вновь созданным объектом. Обратите внимание, что на этом уровне абстракции информация о типе объекта не имеет значения. Предоставляется только необходимый размер выделяемой памяти.</p>
  </li>
  <li>
    <p class="justify-style">Write(address, value): записывает указанное значение по указанному адресу. Здесь мы также абстрагируемся от того, рассматриваем ли мы объектное поле (в объектно-ориентированном программировании), глобальную переменную или любой другой тип организации данных.</p>
  </li>
  <li>
    <p class="justify-style">Read(address): считывает значение с указанного адреса.</p>
  </li>
</ul>

<p class="justify-style">В простейшем мире, где не существует ни одного алгоритма сборки мусора, эти три операции имеют тривиальные реализации (написанные на псевдокоде в стиле C в <a href="#l-1-6">листинге 1-6</a>).</p>

<br>
<figure id="l-1-6" class="figure">
  <pre class="code border border-secondary">
    <code class="language-c">
      Mutator.New(amount)
      {
        return Allocator.Allocate(amount);
      }
      Mutator.Write(address, value)
      {
        *address = value;
      }
      Mutator.Read(address) : value
      {
        return *address;
      }
    </code>
  </pre>
  <figcaption class="figure-caption">Листинг 1-6. Реализация трех основных методов Мутатора без автоматизированного управления памятью</figcaption>
</figure>

<p class="justify-style">Но в мире автоматизированной сборки мусора эти три операции являются местами, где Mutator взаимодействует со сборщиком мусора (<span class="fw-bold fst-italic">Collector</span>) и механизмом распределения (<span class="fw-bold fst-italic">Allocator</span>). То, как выглядит это сотрудничество и насколько оно нарушает простоту предыдущих реализаций, является одной из самых важных проблем проектирования. Наиболее распространенным улучшением, с которым вы встретитесь в этой книге, является добавление так называемого <span class="fw-bold fst-italic">барьера</span> — это будет либо <span class="fw-bold fst-italic">барьер чтения</span>, либо <span class="fw-bold fst-italic">барьер записи</span>. Барьер — это способ дополнения операции (либо до, либо после). Барьеры позволяют нам синхронизироваться (прямо или косвенно, синхронно или асинхронно) с механизмом сборщика мусора, чтобы информировать о выполнении программы и использовании памяти. Три метода из <a href="#l-1-6">листинга 1-6</a> являются точками инъекции, к которым может захотеть подключиться каждый сборщик мусора. Мы вернемся к некоторым из наиболее распространенных возможных вариаций в следующих главах при описании различных алгоритмов сборки мусора.</p>

<p class="justify-style"> В повседневной реальности разработчиков наиболее распространенной реализацией абстракции Mutator является хорошо известное понятие потока. Он идеально подходит под определение — это единый блок, который запускает код, который мутирует объекты и ссылается на графы между объектами. Для нас это совершенно интуитивно понятно, потому что подавляющее большинство самых популярных сред выполнения используют эту реализацию. Среди множества других функций потоки через некоторый дополнительный уровень взаимодействуют с операционной системой, чтобы разрешить операции New, Write и Read.</p>

<p class="justify-style">Мутаторы не обязательно должны быть реализованы как потоки операционной системы. Популярным примером может быть экосистема Erlang с ее процессами — они управляются как сверхлегкие сопрограммы, живущие в самой среде выполнения. Их можно рассматривать как так называемые «зеленые потоки», но в терминах Erlang VM лучше называть их «зелеными процессами», поскольку разделение, навязываемое средой выполнения, намного сильнее, чем между потокоподобными сущностями. Это сущности, управляемые на уровне среды выполнения, а не на уровне операционной системы. Другая распространенная реализация Мутатора может быть основана на так называемых <span class="fw-bold fst-italic">волокнах</span>, легких единицах выполнения, реализованных как в Linux, так и в Windows.</p>

<p class="h5 p2 fw-bold">Аллокатор</p>

<p class="justify-style">Мутатор должен иметь возможность потреблять операцию «New», которую мы обсуждали в предыдущем пункте. Когда дело доходит до внутреннего устройства этих методов, рано или поздно нужно упомянуть еще одну очень важную концепцию — <span class="fw-bold fst-italic">Аллокатор</span>. Проще говоря, Аллокатор — это сущность, отвечающая за управление динамическим выделением и освобождением памяти.</p>

<p class="justify-style">Распределитель должен обеспечивать две основные операции:</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style">Allocate(amount): Выделяет указанный объем памяти. Это, очевидно, может быть расширено методами, способными выделять память для определенного типа объекта, если информация о типе доступна для Allocator. Как мы видели, это внутренне используется операцией Mutator.New.</p>
  </li>
  <li>
    <p class="justify-style">Deallocate(address): Освобождает память по указанному адресу, чтобы сделать ее доступной для будущих выделений. Обратите внимание, что в случае автоматического управления памятью этот метод является внутренним и не отображается для Mutator (и, следовательно, никакой пользовательский код не может вызвать его явно).</p>
  </li>
</ul>

<p class="justify-style">Идея может показаться очень простой, если не сказать тривиальной. Но, как мы увидим, это не так просто, как можно было бы ожидать. В дизайне распределителя есть много разных аспектов. И, как всегда, все упирается в компромиссы, в основном между производительностью, сложностью реализации (что напрямую ведет к удобству обслуживания) и другими. Мы углубимся в два самых популярных типа распределителей: <span class="fw-bold fst-italic">последовательный</span> и <span class="fw-bold fst-italic">свободный список</span>. Но поскольку это деталь реализации, будет гораздо лучше узнать о них в конкретном контексте .NET в Главе 4.</p>

<p class="h5 p2 fw-bold">Сборщик</p>

<p class="justify-style">В то время как мы определили Мутатор как сущность, которая отвечает за выполнение кода приложения, мы можем аналогичным образом определить <span class="fw-bold fst-italic">Сборщик</span> как сущность, которая запускает код сборки мусора (автоматического освобождения памяти). Другими словами, вы можете рассматривать Сборщик как часть программного обеспечения (код) или поток, выполняющий его, или и то, и другое. Это зависит от контекста.</p>

<p class="justify-style">Как сборщик узнает, какие объекты больше не нужны и могут быть освобождены? Это неразрешимая задача, потому что ему пришлось бы угадывать будущее. Знание того, будет ли конкретный объект снова использоваться, зависит от кода, который будет выполнен, и это может, кроме того, зависеть от независимых факторов, таких как действия пользователя, внешние данные и т. д. Идеальный сборщик должен знать <span class="fw-bold fst-italic">жизнеспособность</span> объекта — живые объекты — это те, которые понадобятся. Напротив, <span class="fw-bold fst-italic">мертвые (или мусорные) объекты</span> не будут использоваться и могут быть уничтожены. Очевидно, что сборщик называется <span class="fw-bold fst-italic">Сборщиком Мусора</span> или GC сокращённо.</p>

<p class="justify-style">Есть интересное следствие сотрудничества между Mutator, Allocator и Collector. Обратите внимание еще раз, что, поскольку не существует открытого метода Allocator.Deallocate, Mutator не имеет возможности явно освобождать полученную память. Mutators могут только просить выделять все больше и больше памяти, как если бы ее источник был бесконечным. Это действительно означает, что механизм Garbage Collection на самом деле является симуляцией компьютера с бесконечным объемом памяти. То, как работает эта симуляция и насколько она эффективна, зависит от реализации.</p>

<p class="justify-style">Можно придумать специальный сборщик мусора, который вообще не освобождает выделенную память. Он называется <span class="fw-bold fst-italic">Null</span> или <span class="fw-bold fst-italic">Zero Garbage Collector</span>. Он будет работать правильно только на компьютерах с бесконечным объемом памяти, чего, к сожалению, пока не существует. Но Null Garbage Collector не лишены практического применения. Их можно использовать, например, для очень короткоживущих программ, где допустим неограниченный рост памяти. Возможно, они будут становиться все более и более популярными в мире без серверных, коротко работающих одиночных функций. Пример черновика такого Zero Garbage Collector для .NET представлен в Главе 15.</p>

<p class="justify-style">Поскольку невозможно знать <a class="fw-bold" data-bs-toggle="modal" data-bs-target="#EscapeAnalysis">жизнеспособность объекта</a>, Сборщик основан на другом, на достижимости любым Мутатором. Достижимость объекта означает, что существует цепочка ссылок (начинающаяся с доступной памяти какого либо Мутатора) между объектами, которая в конечном итоге приводит к этому объекту (см. <a href="#f-1-10">Рисунок 1-10</a>). Достижимость, очевидно, не подразумевает жизнеспособность объекта, но это лучшее приближение, которое у нас есть. Если объект недостижим ни из одного Мутатора, он больше не может использоваться, поэтому он мертв (мусор) и может быть безопасно утилизирован. Обратное, очевидно, неверно. Достижимый объект может оставаться достижимым вечно (хранится некоторым сложным графом ссылок), но из-за условий выполнения к нему никогда не будет доступа, и как таковой он мертв. Фактически, это несоответствие между жизнеспособностью и достижимостью является причиной большинства утечек управляемой памяти.</p>

<figure id="f-1-10" class="figure">
  <img src="content/img/1-10.png" class="img-fluid" alt="Рисунок 1-10" max-width="600">
  <figcaption class="figure-caption">Рисунок 1-10. Достижимость – объекты C и F недостижимы, поскольку нет пути из корней (местоположений Мутатора), ведущего к ним.</figcaption>
</figure>

<p class="justify-style">Начальные точки Мутатора с точки зрения достижимости называются корнями. Что они собой представляют, зависит
  от конкретной реализации Мутатора. Но в большинстве распространенных случаев, когда Мутатор — это просто поток
  (представленный собственным потоком операционной системы), корни могут быть:</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style">Локальные переменные и аргументы подпрограмм – помещающиеся в стек или хранящиеся в регистрах.</p>
  </li>
  <li>
    <p class="justify-style">Статически размещенные объекты (например, глобальные переменные) – находящиеся в куче</p>
  </li>
  <li>
    <p class="justify-style">Другие внутренние структуры данных, хранящиеся внутри самого Сборщика.</p>
  </li>
</ul>

<p class="justify-style">Рассмотрев три основных строительных блока — мутатор, аллокатор и коллектор — мы теперь можем перейти к знакомству с множеством различных подходов к автоматическому управлению памятью. Хотя и заманчиво предоставить полный список с подробным описанием всех из них, это гораздо больше, чем может охватить эта книга. Вместо этого вы узнаете о некоторых основных, наиболее популярных подходах, которые можно встретить в современных языках.</p>

<hr class="border-2">

<p id="chapter1-4" class="h3 p-2">Подсчет ссылок</p>

<p class="justify-style">Текст...</p>

<p class="justify-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-5" class="h3 p-2">Отслеживающий сборщик</p>
<p class="justify-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-6" class="h3 p-2">Резюме</p>
<p class="justify-style">Текст...</p>

<hr class="border-2">
<p id="chapter1-6-1" class="h4 p2">Правило 1 — Самообразование</p>

<p class="justify-style">Текст...</p>
<!--
Глава 1: Базовые концепции
    Термины, связанные с памятью
        Статическое выделение
        Регистровая машина.
        Стек
        Стековая машина
        Указатель
        Куча
    Ручное управление памятью
    Автоматическое управление памятью
        Аллокатор, мутатор и сборщик
    Подсчет ссылок
    Отслеживающий сборщик
        Фаза маркировки
    Резюме
        Правило 1 — Самообразование
-->

<!-- Modal -->
<div class="modal fade" id="AccessViolationExceptionModal" tabindex="-1" aria-labelledby="AccessViolationExceptionModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="AccessViolationExceptionModalLabel">AccessViolationException</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <span class="fw-bolder">AccessViolationException</span> или другие повреждения кучи часто могут быть вызваны автоматическим управлением памятью, не потому что это причина, а потому что это самый тяжелый компонент, связанный с памятью в среде. Таким образом, у него самая большая вероятность обнаружить любые несогласованные состояния памяти.
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal fade" id="TailCalls" tabindex="-1" aria-labelledby="TailCallsLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="TailCallsLabel">Tail Calls</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Есть одно интересное исключение, называемое «TailCalls», которое здесь не описывается из-за его краткости.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal fade" id="CacheLocality" tabindex="-1" aria-labelledby="CacheLocalityLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="CacheLocalityLabel">Cache Locality</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Примечание: Мы рассмотрим важность шаблонов доступа к памяти в контексте использования кэша в Главе 2.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal fade" id="IndexRegisters" tabindex="-1" aria-labelledby="IndexRegistersLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="IndexRegistersLabel">Index Registers</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>В контексте адресации памяти важным усовершенствованием стал индексный регистр, введенный в машину Manchester Mark 1, преемницу «Baby». Индексный регистр позволял нам ссылаться на память косвенно, добавляя ее значение к другому регистру. Следовательно, для работы с непрерывными областями памяти, такими как массивы, требовалось меньше инструкций.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal fade" id="LocalThread" tabindex="-1" aria-labelledby="LocalThreadLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="LocalThreadLabel">Local (thread)</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Примечание: Это не совсем верно, так как вы можете передать указатель на переменную стека другим потокам. Однако это определенно ненормальное использование.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal fade" id="VariableSize" tabindex="-1" aria-labelledby="VariableSizeLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="VariableSizeLabel">Variable Size</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Примечание: В связи с динамической природой кучи существуют функции, позволяющие изменять размер (перераспределять) заданного блока памяти.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal fade" id="NullPointer" tabindex="-1" aria-labelledby="NullPointerLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="NullPointerLabel">NULL Pointer</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Примечание: Детали реализации значения NULL в случае .NET будут объяснены в главе 10.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal fade" id="EscapeAnalysis" tabindex="-1" aria-labelledby="EscapeAnalysisLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="EscapeAnalysisLabel">Анализ ускользания</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Примечание: В главе 4 мы обсудим анализ ускользания — метод определения истинной жизнеспособности указателей, по крайней мере, для некоторых особых случаев.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>