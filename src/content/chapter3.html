<p id="chapter3" class="h2 p-2">Глава 3: Измерение памяти </p>

<hr class="border-2">

<p class="justify-style">Возможно, удивительно говорить об измерениях почти в самом начале книги. Мы еще практически ничего не сказали о управлении памятью в .NET, а уже рассматриваем связанные с этим инструменты. Это хорошо продуманное решение. Во-первых, с помощью описанных здесь инструментов мы часто будем иллюстрировать конкретные концепции, которые будут обсуждаться позже. Во-вторых, хотя мы стремимся сделать эту книгу сбалансированной, она имеет очень практическое значение. При рассмотрении различных тем мы коснемся реальных проблем и примеров. С помощью инструментов, описанных в этой главе, вы сможете увидеть, как эти проблемы можно выявить и диагностировать. Эти инструменты помогут глубже понять реализацию теоретических концепций. Кроме того, они незаменимы для исследования возникающих проблем.</p>

<p class="justify-style">Не зная, какие инструменты использовать, сложно проверить, есть ли в вашем процессе проблемы с памятью. Вы не знаете, как убедиться в том, что высокое потребление ресурсов ЦП или памяти связано с управлением памятью .NET. Вы не знаете, в чем может быть причина нежелательного наблюдаемого поведения. Правда в том, что не существует одного, супер универсального швейцарского армейского ножа. Часто необходимо использовать несколько инструментов, чтобы понять поведение вашего процесса. Чтобы в полной мере комфортно чувствовать себя в теме управления памятью, лучше всего научиться пользоваться каждым из них. Мы опишем здесь широкий спектр инструментов. С одной стороны, есть коммерческие продукты с удобными в использовании пользовательскими интерфейсами, где все просто, поэтому можно быстро получить много ответов. Однако эти инструменты позволяют только то, что было задумано их создателями, с очень ограниченной настройкой. С другой стороны, существуют низкоуровневые инструменты, такие как WinDbg, для действительно глубокого анализа. Знание десятков волшебных команд, которые следует использовать в правильном порядке, позволит вам расследовать сбои или детали выделенного типа. Между этими крайностями есть много других инструментов, которые всегда являются компромиссом между универсальностью и простотой использования. По нашему опыту, таких коммерческих программ высокого уровня почти всегда достаточно. Но это «почти» имеет большое значение. Время от времени вы будете сталкиваться с проблемой, которую невозможно решить только с помощью этих программ. Другими словами, рано или поздно ваши руки испачкаются смазкой из двигателя. А когда вы не найдете нужный инструмент, написать свой собственный может быть не так уж и сложно. Эта книга покажет вам несколько приемов самостоятельного проведения анализа!</p>

<p class="justify-style">Возможно, вас удивит отсутствие инструментов статического анализа кода среди представленных здесь. Почти все инструменты основаны на анализе времени выполнения. Это связано с тем, что управление памятью во многом зависит от контекста выполнения. Например, даже самый неэффективный фрагмент кода не окажет негативного влияния на процесс, если связанные с ним операции будут выполняться только один раз в час. Статический анализ кода может помочь, но он также может создавать шум и заставлять вас излишне концентрироваться на нерелевантных частях кода.</p>

<p class="justify-style">Написание производительного кода может быть более сложным, чем написание функционального или чистого кода. Это связано с тем, что очень трудно предсказать, как на самом деле будет работать данный фрагмент кода или каковы приемлемые накладные расходы для данного приложения. Существуют инструменты, которые показывают нарушение некоторых пороговых значений. Но даже в этом случае, без глубокого понимания предмета, вы не можете быть уверены, будут ли эти пороговые значения применимы к вашему приложению в вашей конкретной среде. Вот почему эта глава важна: она помогает вам преодолеть разрыв между теорией и практикой.</p>

<p class="justify-style">Средства, используемые для измерения поведения программ .NET, радикально различаются в зависимости от операционной системы. Именно поэтому в главе рассматриваются два самых популярных из них – Windows и Linux. Из-за очень низкой популярности использования .NET на macOS инструменты (кроме инструментов CLI) для этой платформы в этой книге не описываются.</p>

<p class="justify-style">Хотя знания для интерпретации результатов работы этих инструментов будут предоставлены несколько позже в книге, мы приглашаем вас опробовать их во время чтения, хотя бы немного. Благодаря этому вы приобретете некоторое знакомство, которое пригодится в следующих главах. Очевидно, что не стесняйтесь пропускать инструменты, с которыми вы уже знакомы.</p>

<p class="justify-style">Обратите также внимание, что эта глава немного страдает от проблемы «курицы и яйца» — невозможно продемонстрировать практическую сторону многих тем, связанных с сборщиком мусора (GC), не используя описанные здесь инструменты, но эти инструменты часто требуют хорошего понимания самих тем, связанных с GC. Тем не менее, мы решили объединить все инструменты в одной главе, чтобы избежать перегрузки всей книги и дать вам единое место, к которому можно вернуться при необходимости. Поэтому не беспокойтесь, если вы сразу не поймете каждую деталь, описанную здесь. Мы ожидаем, что вы будете время от времени возвращаться к этой главе, используя эти инструменты в своей повседневной работе, с полным пониманием, полученным из этой книги.</p>

<hr class="border-2">
<p id="chapter3-1" class="h3 p-2">Начинайте измерять на ранней стадии</p>

<p class="justify-style">Какое самое важное правило в вопросах оптимизации производительности? Будь то эксперты или просто разработчики с некоторым опытом решения подобных проблем, все отвечают одинаково: начинайте измерять как можно раньше. Вероятно, каждый слышал фразу о том, что преждевременная оптимизация является корнем всех зол. Во-первых, не имеет смысла тратить часы или дни на оптимизацию кода, который имеет незначительное влияние на приложение. А еще хуже то, что это обязательно сделает код неоправданно сложным, увеличивая стоимость его поддержки. Хорошим правилом будет противоположный подход — вместо того чтобы заранее сосредотачиваться на оптимизации, начните с измерений, чтобы выяснить, есть ли вообще конкретные потребности в производительности. И поскольку эта книга посвящена управлению памятью в .NET, это приводит нас к следующему общему правилу — Начинайте измерять работу сборщика мусора (GC) как можно раньше — которое мы представим в конце этой главы.</p>

<p class="justify-style">Каждое измерение может сопровождаться большей или меньшей погрешностью. Кроме того, измерение может мешать наблюдаемому процессу. Мы знаем этот принцип из физики, и в информатике всё обстоит точно так же. Поэтому ответ на вопрос «как измерять» может быть либо очень простым (если не углубляться в детали), либо очень сложным (если учитывать точность). Разные инструменты предоставляют разную степень точности, и мы немного об этом поговорим. Однако статистические рассуждения о погрешностях измерений выходят за рамки этой книги. Просто имейте в виду, что определённые неточности могут возникнуть каждый раз, когда вы что-то измеряете.</p>

<p class="justify-style">Тем не менее, учитывая его важность в контексте измерений, мы хотим выделить здесь несколько ключевых концепций и распространённых заблуждений.</p>

<hr class="border-2">
<p id="chapter3-1-1" class="h4 p-2">Накладные расходы и инвазивность</p>

<p class="justify-style">Когда дело доходит до инструментов профилирования, всегда важно помнить о двух наиболее важных концепциях:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Накладные расходы</span>: Очень сложно найти инструмент, который не замедляет приложение или не потребляет больше ресурсов каким-либо образом. В этом случае мы говорим о накладных расходах инструмента, которые обычно выражаются в процентах. Это означает, например, что время отклика веб-приложения может увеличиться на несколько процентов. Или эти проценты могут ухудшить плавность анимаций в desktop-приложении. Некоторые инструменты вызывают практически незаметные накладные расходы всего в несколько процентов или даже менее одного процента. Такие инструменты с минимальными накладными расходами можно использовать даже в производственной среде. С другой стороны, существуют инструменты, которые замедляют ваше приложение на порядки. Обычно они предоставляют большое количество детальной информации. Однако из-за значительных накладных расходов их использование ограничивается средами разработки или рабочими станциями отдельных разработчиков.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Инвазивность</span>: Эта концепция схожа и касается того, насколько инструмент влияет на поведение приложения. Требуется ли перезапуск приложения для использования инструмента? Нужны ли дополнительные разрешения или установленные расширения? В идеале ненавязчивое решение можно включать и выключать во время работы приложения, не оказывая на него никакого влияния. С другой стороны, полностью навязчивое решение потребует перекомпиляции вашего приложения и повторной его деплоизации в заданную среду.</p>
    </li>
</ul>

<hr class="border-2">
<p id="chapter3-1-2" class="h4 p-2">Выборка против трассировки</p>

<p class="justify-style">Еще одной характеристикой профилирующих инструментов является способ сбора диагностической информации. Существует два основных подхода:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Трассировка или инструментирование</span>: В этом подходе диагностические данные собираются во время конкретных, выделенных событий (отсюда и другое название — событийный). Примером может служить сохранение трассируемых данных при открытии или закрытии файла, при щелчке мышью или при начале сборки мусора. Неоспоримым преимуществом этого решения является точность данных, поскольку они поступают в момент возникновения события. Однако, если такие события происходят очень часто или вычисление их содержимого требует больших затрат, это может вызвать значительные накладные расходы. Поэтому этот вид механизма не используется для частых событий, таких как вход в функцию или возврат из нее, если только вы можете позволить себе такие накладные расходы, например, на локальной рабочей станции разработчика.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Выборка</span>: В этом подходе точность жертвуется ради снижения накладных расходов. Идея состоит в том, чтобы собирать диагностические данные периодически (отсюда и другое название — временной). Чем реже вы это делаете, тем меньше будут накладные расходы, но одновременно с этим уменьшится точность измерений. Типичным примером такого подхода является регулярная проверка стеков вызовов функций на всех процессорах, например, каждые 1 мс. Это позволяет статистически определить, какие функции занимают больше всего времени на выполнение. Хотя, конечно, существует вероятность, что вы можете не зафиксировать информацию о функциях, которые всегда выполняются быстрее, чем за 1 мс.</p>
    </li>
</ul>

<hr class="border-2">
<p id="chapter3-1-3" class="h4 p-2">Дерево вызовов</p>

<p class="justify-style">Одной из часто используемых визуализаций поведения потоков приложения является построение дерева вызовов. В таком дереве каждая вершина представляет одну функцию. Подчиненные вершины представляют другие функции, которые были вызваны данной функцией. Каждая функция также сопровождается некоторыми измерениями, чаще всего общим временем выполнения. На практике для каждой функции очень часто используются две связанные метрики:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Эксклюзивная (Exclusive)</span>: Измеряет значение только для этой функции. В случае времени выполнения это будет время, проведенное непосредственно в этой функции (без учета подчиненных функций).</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Инклюзивная (Inclusive)</span>: Измеряет значение для данной функции и сумму значений всех ее потомков. В случае времени выполнения это будет время, проведенное в самой функции, во всех других функциях, вызванных ею, во всех функциях, вызванных ими, и так далее, рекурсивно.</p>
    </li>
</ul>

<p class="justify-style">Кроме того, иногда определяется процент данного показателя относительно всего исследуемого диапазона. Это известно как инклюзивный % и эксклюзивный % измерений. Рассмотрим пример на <a href="#f-3-1">рисунке 3-1</a>, показывающем результаты гипотетического профилировщика.</p>

<p class="justify-style">Вы видите здесь, что 100% времени работы программы было потрачено в функции main — это составило 3 секунды. Функция main просто вызывает все остальные функции, поэтому такое поведение ожидаемо. Однако только 22% этого времени было потрачено непосредственно в самой функции main; остальное время ушло на выполнение других функций, вызванных ею. Например, 78% времени было потрачено на выполнение функции SomeClass.Method1. Затем 66,7% времени работы программы было затрачено на вызов функции SomeClass.HelperMethod. Обходя это дерево вызовов, вы быстро сможете определить, какие компоненты приложения работают медленнее всего.</p>

<p class="justify-style">Обратите также внимание, что такие деревья обычно представляют агрегированные данные. В примере с <a href="#f-3-1">рисунка 3-1</a> агрегируются все упомянутые вызовы методов. Таким образом, метод main был вызван всего один раз, в то время как метод HelperMethod был вызван 2000 раз (что объясняет, почему его агрегированное инклюзивное время так велико). Следовательно, анализ такого дерева включает поиск методов, которые выполняются долго, или методов, которые сами по себе не являются медленными, но вызываются множество раз.</p>

<figure id="f-3-1" class="figure">
    <img src="content/img/3-1.png" class="img-fluid" alt="Рисунок 3-1" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-1. Пример дерева вызовов, показывающего данные о производительности</figcaption>
</figure>

<p class="justify-style">Ту же идею можно использовать для визуализации использования памяти, где каждая вершина представляет собой определенный тип объекта. Типы объектов, на которые ссылается данная вершина, отображаются как ее дочерние элементы. При анализе производительности или потребления памяти вашего приложения вы часто будете использовать такие типы визуализации.</p>

<hr class="border-2">
<p id="chapter3-1-4" class="h4 p-2">Графы объектов</p>

<p class="justify-style">В контексте памяти часто используется граф, представляющий отношения между объектами в памяти, называемый графом объектов или графом ссылок. Пример такого графа можно было видеть на <a href="#f-1-12" onclick="loadContent('chapter1.html', 'f-1-12')">рисунке 1-12</a> в первой главе и он также иллюстрируется на <a href="#f-3-2">рисунке 3-2</a> он показывает набор объектов, ссылающихся друг на друга, с единственным корневым элементом. Визуализация всего графа затруднительна, поскольку он может быть очень большим, поэтому обычно анализируют только его небольшую часть. С их помощью можно отображать как агрегированную информацию (сколько экземпляров данного типа содержат ссылки на другие объекты), так и информацию о конкретном экземпляре.</p>

<figure id="f-3-2" class="figure">
    <img src="content/img/3-2.png" class="img-fluid" alt="Рисунок 3-2" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-2. Пример графа объектов. Дополнительно помечен сохраненный подграф объекта B</figcaption>
</figure>

<p class="justify-style">При работе с графами объектов возникают три важные концепции, которые появляются в различных инструментах, которыми вам представится возможность пользоваться:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Кратчайший путь к корню</span>: Для данного объекта это самый короткий путь ссылок к какому-либо корневому элементу. На <a href="#f-3-2">рисунке 3-2</a> кратчайший путь к корню для объекта H — это путь root-A-H. Также существуют более длинные пути: root-A-C-G-H и root-A-B-G-H. Кратчайший путь к корню может быть важен, так как он чаще всего указывает на главные и наиболее значимые связи между объектами, давая хорошее представление о главной причине, из-за которой объект считается недостижимым (и, следовательно, неподлежащим удалению). Другие пути обычно создаются как побочный эффект других сложных зависимостей. Однако иногда кратчайший путь к корню может быть обманчивым, если он создается вспомогательными ссылками, такими как кэши. Это может быть случай на <a href="#f-3-2">рисунке 3-2</a>, где объект A, вероятно, содержит ссылку на объект H для удобства (например, для кэширования), в то время как фактический "владелец" объекта H находится среди объектов B, C или G.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Подграф зависимостей</span>: Для данного объекта это подграф, который включает сам объект и все объекты, прямо или косвенно на него ссылающиеся. На <a href="#f-3-2">рисунке 3-2</a> подграф зависимостей объекта B включает объект B и объекты D, E, F, G и H.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Подграф удерживаемых объектов</span>: Для данного объекта это подграф, который был бы удален, если бы сам этот объект был удален. Поскольку граф зависимостей может быть сложным, удаление объекта не обязательно означает, что все объекты, на которые он ссылается, также будут удалены. Ссылки на них могут сохраняться другими объектами. Подграф удерживаемых объектов для объекта B на рисунке 3-2 включает объект B и объекты D, E и F.</p>
    </li>
</ul>

<p class="justify-style">Вместе с этими концепциями существуют также различные интерпретации того, как указывается размер объекта в инструментах:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Поверхностный размер (Shallow size)</span>: Сумма поверхностного размера объекта и всех поверхностных размеров объектов, на которые он прямо или косвенно ссылается. Иными словами, это общий размер всех объектов в подграфе зависимостей. Это тоже несложно вычислить, так как нужно просто найти подграф зависимостей объекта и просуммировать все поверхностные размеры включенных объектов.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Удерживаемый размер (Retained size)</span>: Общая сумма всех объектов в графе удержания. Иными словами, удерживаемый размер — это объем памяти, который может быть освобожден после удаления данного объекта. Чем больше объектов разделяется различными ссылками в графе объектов, тем дольше требуется время для его вычисления. Удерживаемый размер меньше общего размера. Это сложно вычислить, так как это требует сложного анализа всего графа объектов.</p>
    </li>
</ul>

<p class="justify-style">Каждый раз, когда используемый вами инструмент говорит о размере объекта, стоит задаться вопросом, какой из упомянутых "размеров" принимается во внимание.</p>

<hr class="border-2">
<p id="chapter3-1-5" class="h4 p-2">Статистика</p>

<p class="justify-style">Каждый раз, когда вы агрегируете измерения различными способами, вы в той или иной степени используете статистические инструменты. Если вы делаете это бессознательно, это может привести к риску ошибочных выводов. Например, самый распространенный метод агрегации данных — это расчет среднего значения, которое должно давать представление о "типичном значении". Однако у среднего значения есть два существенных недостатка: его результаты не указывают на какой-либо конкретный пример (подумайте о том, как в среднестатистической семье 2,43 ребенка), и оно легко скрывает истинную природу распределения данных (что скоро будет продемонстрировано). Такие проблемы, как и другие простые меры, например дисперсия, отлично иллюстрируются так называемым "квартетом Анскомба" (см. <a href="#f-3-3">рисунок 3-3</a>, взятый из Википедии). Иногда совершенно различные наборы данных могут привести к одинаковым статистическим выводам.</p>

<figure id="f-3-3" class="figure">
    <img src="content/img/3-3.png" class="img-fluid" alt="Рисунок 3-3" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-3. Квартет Энскомба – четыре набора данных с одинаковым средним значением и дисперсией данных x и y. Источник: Википедия</figcaption>
</figure>

<p class="justify-style">Причины такой популярности среднего значения заключаются в его интуитивности и возможности легко вычислять его без хранения отдельных выборок. Другие методы агрегации требуют сохранения всех выборок, что может создать значительные накладные расходы для инструмента.</p>

<p class="justify-style">Какие другие методы агрегации стоит использовать? Наиболее распространенные из них включают:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Перцентиль</span>: Значение, ниже которого находится заданный процент выборок. Например, 95-й перцентиль — это значение, ниже которого находятся 95% выборок. Это отличный показатель данных, которые вас интересуют, не учитывая при этом очень аномальные измерения. Мы настоятельно рекомендуем вам измерять перцентили с помощью используемых инструментов. Перцентили часто определяются бизнес-требованиями. Например, вы можете захотеть убедиться, что 90% времени ответа вашего приложения не превышают 1 секунду, а 99% не превышают 4 секунды. Измерение 90-го и 99-го перцентилей времени ответа позволяет вам легко контролировать эти ожидания.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Медиана</span>: Это значение, которое встречается чаще всего в наборе данных. Она может быть полезна для категориальных данных, но не так хорошо подходит для непрерывных данных.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Квартили</span>: Значение, которое делит выборки на верхнюю и нижнюю половины. Обратите внимание, что медиана фактически является 50-м перцентилем. Она лучше отражает типичное значение, так как более устойчива к сильно различающимся выборкам. Кроме того, она указывает на одно из реальных значений, а не на искусственное, рассчитанное.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Гистограмма</span>: Графическое представление распределения выборок. Она показывает, сколько выборок попадает в конкретные диапазоны значений. Это лучший возможный способ измерения, так как он демонстрирует все распределение данных.</p>
    </li>
</ul>

<p class="justify-style">Все эти метрики представлены на <a href="#f-3-4">рисунке 3-4</a>, который показывает гистограмму распределения времени ответа — сколько ответов попадает в каждый временной диапазон (выраженный в миллисекундах). Из гистограммы очевидно, что наиболее распространённое время ответа находится в пределах 110 ± 5 мс, и чем больше время ответа отличается от этого значения, тем реже оно встречается. Более того, можно сказать, что:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style">Среднее время ответа составляет 104,3 мс.</p>
    </li>
    <li>
        <p class="justify-style">10% всех ответов короче 60 мс (10-й перцентиль).</p>
    </li>
    <li>
        <p class="justify-style">Медиана равна 100 мс (50-й перцентиль).</p>
    </li>
    <li>
        <p class="justify-style">90% всех ответов короче 150 мс (90-й перцентиль).</p>
    </li>
</ul>

<figure id="f-3-4" class="figure">
    <img src="content/img/3-4.png" class="img-fluid" alt="Рисунок 3-4" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-4. Пример гистограммы со значениями медианы, 10-го и 90-го процентилей – нормальное распределение данных</figcaption>
</figure>

<p class="justify-style">Распределение, показанное на <a href="#f-3-4">рисунке 3-4</a>, очень похоже на так называемое нормальное распределение, которое часто также называют кривой в форме колокола из-за его характерной формы. Многие измерения будут относиться к этой категории, что делает интерпретацию перцентилей (и даже среднего значения) достаточно логичной.</p>

<p class="justify-style">Однако будьте особенно внимательны к появлению так называемых бимодальных (и многомодальных в общем случае) распределений данных. Интерпретация таких данных только через среднее значение, медиану или перцентили может привести к ошибочным выводам (см. <a href="#f-3-5">рисунок 3-5</a>). В этом примере измеряются два типа ответов (фактически, две различные нормальные кривые), поэтому любая агрегация этих данных будет вводить в заблуждение. Лучше сказать, что существуют две категории ответов с медианами около 40 и 150 мс (и, вероятно, стоит исследовать, почему возникает такое бимодальное время ответа в первую очередь).</p>

<figure id="f-3-5" class="figure">
    <img src="content/img/3-5.png" class="img-fluid" alt="Рисунок 3-5" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-5. Пример гистограммы с отображением значений медианы, 10-го и 90-го процентилей – бимодальное распределение данных</figcaption>
</figure>

<p class="justify-style">К счастью, многомодальное распределение легко обнаружить визуально на гистограмме; именно поэтому так критически важно иметь графическое представление данных при измерении чего-либо (или хотя бы автоматическое указание на обнаружение многомодального распределения).</p>

<p class="justify-style">Чем больше инструмент предлагает различных измерений, помимо среднего значения, тем лучше. К сожалению, подавляющее большинство инструментов всё ещё используют только среднее значение (при этом очень немногие показывают какие-либо гистограммы). Нужно быть крайне осторожным при формулировании выводов. Идеальным решением будет попытаться использовать инструмент, который покажет вам распределение результатов с помощью перцентилей или в виде гистограммы.</p>

<hr class="border-2">
<p id="chapter3-1-6" class="h4 p-2">Латентность против пропускной способности</p>

<p class="justify-style">Два понятия очень важны в контексте любого анализа и оптимизации производительности. К сожалению, их также иногда неправильно понимают и неправильно интерпретируют. Чаще всего вы думаете, что одно вытекает из другого и что они полностью зависят друг от друга. Поэтому стоит дать им несколько слов пояснения. Начнем с их простых определений:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Латентность</span> (latency): Время, необходимое для выполнения заданного действия. Оно измеряется в некоторых единицах времени – днях, часах, миллисекундах и так далее.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Пропускная способность</span> (throughput): Количество действий, выполненных за определенный промежуток времени. Он измеряется в действиях (или в том, что представляет собой отдельный конкретный элемент) в единицу времени — например, в байтах в секунду, итерациях в миллисекунду или книгах в год.</p>
    </li>
</ul>

<p class="justify-style">Простое уравнение, называемое законом Литтла, обозначает взаимосвязь между этими показателями:</p>

<p class="justify-style"><span class="fw-bold fst-italic">occupancy = latency * throughput</span></p>

<p class="justify-style">Где <span class="fw-bold fst-italic">occupancy</span> (занятость) - означает количество действий в течение периода времени, обозначенного задержкой. Важно понимать, что уравнение применимо к стабильной системе, в которой нет неестественной очереди или динамической адаптации к изменению нагрузки (например, во время запуска или выключения системы).</p>

<p class="justify-style">Эти два понятия чаще всего встречаются в контексте компьютерных сетей, но для наших целей мы используем более полезный контекст веб-приложений. Время обработки одного запроса пользователя является латентностью. Количество пользовательских запросов за единицу времени — это пропускная способность. Занятость будет равна количеству запросов, обработанных в системе за рассматриваемый период времени.</p>

<p class="justify-style">Конечно, снижение латентности (например, путем использования более мощного процессора) позволяет приложению обрабатывать больше пользовательских запросов за единицу времени, что также увеличивает пропускную способность. С другой стороны, вы можете повысить пропускную способность просто за счет увеличения количества параллельно обрабатываемых запросов (например, путем использования большего числа ядер процессора) без изменения латентности (см. <a href="#f-3-6">рисунок 3-6</a>). Общее правило информатики заключается в том, что легче увеличить пропускную способность (путем какой-либо параллелизации), чем снизить латентность (например, с помощью более современного оборудования или улучшения алгоритмов).</p>

<figure id="f-3-6" class="figure">
    <img src="content/img/3-6.png" class="img-fluid" alt="Рисунок 3-6" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-6. Соотношение пропускной способности и задержки: (a) при некоторой базовой задержке обрабатывается 5 запросов в X секунд; (b) при уменьшенной задержке было обработано 7 запросов в X секунд; (c) за счет удвоения распараллеливания пропускная способность удваивается до 10 запросов в X секунд без изменения задержки</figcaption>
</figure>

<p class="justify-style">Конечно, бесконечно увеличивать пропускную способность нельзя. И часто, после некоторого порогового значения, дальнейшее увеличение пропускной способности также может увеличить задержку. Дополнительные затраты на синхронизацию могут отрицательно повлиять на задержку и свести на нет выигрыш от увеличения пропускной способности.</p>

<p class="justify-style">Существует также популярный закон Амдала, вытекающий из того факта, что потенциальное ускорение задержки ограничено последовательными (невозможными для распараллеливания) частями программы. Так, например, если 90% части программы может быть распараллелено, то все равно останется 10%, которые будут выполняться последовательно. Следовательно, максимальное потенциальное ускорение в таких случаях ограничивается максимум десятикратным увеличением.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Обратите внимание, что он распространяется на все приложение и базовые библиотеки, среду выполнения и другие компоненты, а не только на ваш код. Таким образом, в случае ASP.Net веб-приложения, даже если вся обработка запросов может быть распаралленена, все равно могут присутствовать некоторые последовательные части, такие как управление сессиями, части фреймворка/хостинга и части выполнения сборщика мусора.</p>
  </div>
</div>

<hr class="border-2">
<p id="chapter3-1-7" class="h4 p-2">Дампы памяти, трассировка, отладка в реальном времени</p>

<p class="justify-style">Для того чтобы проанализировать состояние вашего приложения, у вас есть несколько стандартных подходов, которые отличаются по инвазивности:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Мониторинг</span>: Обычно означает неинвазивный мониторинг приложения и использование диагностической информации, которую оно генерирует (с помощью отслеживания или выборки). Иногда он принимает более инвазивную форму (например, перезапуск приложения), но его можно использовать в производстве, если накладные расходы достаточно низки.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Дамп ядра (дамп памяти)</span>: Означает сохранение состояния памяти процесса в определенный момент. В большинстве случаев состояние всей памяти сохраняется в файле. Затем этот файл можно проанализировать с помощью различных инструментов, даже на другой машине. Поскольку это копия памяти, дамп памяти может занимать десятки гигабайт, но при наличии соответствующих навыков он может предоставить очень подробную информацию о состоянии вашего приложения. С другой стороны, это всего лишь снимок процесса в определенный момент, и без контекста изменения во времени иногда бывает трудно прийти к конкретным выводам, например, при поиске утечек памяти. Поэтому можно захватить два или более дампа памяти и сравнить их друг с другом, чтобы точно определить изменения. Захват дампа памяти может быть очень инвазивным. Чаще всего он заставляет процесс приостанавливаться на некоторое время, от пары секунд до нескольких минут, если целевое приложение использует много памяти. Важное применение дампов памяти — их автоматическое создание после сбоя приложения, что позволяет позднее исследовать его причину (так называемый посмертный анализ) — следовательно, вы можете также обнаружить имя аварийного дампа как особый случай дампа памяти. На практике понятия аварийного дампа и дампа памяти используются взаимозаменяемо в инструментах, с которыми вы столкнетесь.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Отладка в реальном времени</span>: Наиболее инвазивный подход — подключить отладчик к процессу и пошагово проанализировать выполнение приложения. Это наиболее распространенный подход на машине разработчика. К сожалению, для защищенных или чувствительных производственных сред вам придется полагаться на предыдущие два подхода, что довольно необычно в случае расследования проблем с памятью.</p>
    </li>
</ul>

<hr class="border-2">
<p id="chapter3-2" class="h3 p-2">Окружения Windows и Linux</p>

<p class="justify-style">CLR был представлен общественности в 2000 году вместе с .NET Framework, работающим только на Windows. Одной из главных целей .NET Core было выполнение на большем количестве операционных систем (Linux и OSX). Соответствующий инструментарий для мониторинга и анализа производительности, включая распределение памяти на Linux, должен был ждать версии 3.0, чтобы стать доступным. В этом разделе описывается бесплатный инструментарий, используемый в остальной части книги.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Обратитесь к бесплатной электронной книге по адресу <a href="https://prodotnetmemory.com/assets/files/Chapter03_Pre30LinuxTooling.pdf" target="_blank">https://prodotnetmemory.com/assets/files/Chapter03_Pre30LinuxTooling.pdf</a> в которой описан инструментарий Linux для версий .NET Core до 3.0.</p>
  </div>
</div>

<hr class="border-2">
<p id="chapter3-2-1" class="h4 p-2">Обзор</p>

<p class="justify-style">Инфраструктура мониторинга и трассировки Windows очень зрелая, в том числе в контексте среды выполнения .NET. Доступны два основных компонента: система на основе метрик для предоставления временных рядов измерений и механизм на основе событий, называемый <span class="fw-bold fst-italic">Event Tracing for Windows (ETW)</span>. Этих двух достаточно, чтобы покрыть почти все потребности в мониторинге и диагностике. Также есть механизм Windows Management Instrumentation, но он вообще не используется для наших целей (поскольку он больше предназначен, как следует из его названия, для управления и администрирования).</p>

<p class="justify-style">При разработке .NET выбор в области диагностического механизма был очевидным. Как зрелый .NET Framework, так и его многоплатформенный аналог .NET Core поддерживают ETW (Event Tracing for Windows) как диагностическую платформу на Windows. .NET Core также поддерживает EventPipes — кроссплатформенный канал передачи диагностических событий, который использует именованные каналы (Named Pipes) на Windows и сокеты Unix Domain Sockets для Linux и macOS. Ситуация сложнее с мониторингом на основе метрик. .NET Framework работает только на Windows, поэтому метрики публикуются как счетчики производительности Windows. Для .NET Core, начиная с версии 3.0, счетчики публикуются через EventPipes. Прежде чем рассмотреть инструменты, основанные на счетчиках и событиях, будет интересно взглянуть на инструмент, работающий только на Windows, который обеспечивает уникальное представление адресного пространства процесса.</p>

<hr class="border-2">
<p id="chapter3-2-2" class="h4 p-2">VMMap</p>

<p class="justify-style">Этот отличный инструмент, являющийся частью набора утилит Microsoft Sysinternals, позволяет анализировать адресное пространство процесса с точки зрения операционной системы. В последующих главах мы будем использовать его для того, чтобы увидеть, как приложение .NET использует память, исходя из описанной во второй главе структуры (страницы, которые могут быть выделены или зарезервированы для различных целей).</p>

<p class="justify-style">Это автономный инструмент, который не требует установки и может быть скачан с сайта <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/vmmap">(https://learn.microsoft.com/en-us/sysinternals/downloads/vmmap)</a>. После распаковки и запуска вы можете выбрать процесс, чтобы сразу увидеть анализ его использования памяти (см. <a href="#f-3-7">рисунок 3-7</a>). VMMap обнаруживает страницы, выделенные для стека или загруженных бинарных файлов. Для приложений .NET вы также можете увидеть страницы, выделенные для Управляемой Кучи (Managed Heap).</p>

<figure id="f-3-7" class="figure">
    <img src="content/img/3-7.png" class="img-fluid" alt="Рисунок 3-7" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-7. Образец просмотра простого приложения .NET Framework (например, управляемые кучи были 
правильно обнаружен)</figcaption>
</figure>

<hr class="border-2">
<p id="chapter3-2-3" class="h4 p-2">Счетчики производительности .NET Framework</p>

<p class="justify-style">Механизм так называемых счетчиков производительности (Performance Counters) является наиболее распространенным инструментом для мониторинга практически всех аспектов Windows. Это очень легковесный механизм, который можно описать одной фразой: процессы могут использовать его для обмена диагностическими данными в форме временных рядов метрик. Его огромное преимущество заключается в том, что это полностью ненавязчивый механизм, который не создает заметных накладных расходов. Недостатком является точность — диспетчер производительности получает значения каждую секунду, что может быть недостаточно для ваших конкретных целей. Кроме того, некоторые поставщики не обновляют значения регулярно; например, среда выполнения .NET изменяет счетчики производительности, связанные с сборкой мусора (GC), только после каждой сборки мусора.</p>

<p class="justify-style">Метрики группируются в различные категории. Общая архитектура счетчиков производительности показана на <a href="#f-3-8">рисунке 3-8</a>.</p>

<figure id="f-3-8" class="figure">
    <img src="content/img/3-8.png" class="img-fluid" alt="Рисунок 3-8" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-8. Архитектура счетчика производительности</figcaption>
</figure>

<p class="justify-style">В общем случае несколько процессов могут решить публиковать данные под определенными счетчиками производительности. У каждого счетчика производительности есть несколько важных атрибутов:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Категория</span>: Определяет общий Scope (область действия) счетчика.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Имя</span>: Однозначно идентифицирует счетчик в рамках данной категории.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Имя экземпляра</span>: В системе может быть несколько экземпляров одного и того же счетчика. В большинстве случаев имя экземпляра — это имя процесса.</p>
    </li>
</ul>

<p class="justify-style">Сочетание, которое однозначно идентифицирует счетчик производительности, записывается как "\<Категория>(<Экземпляр>)\<Имя>". Например, счетчик, указывающий на использование CPU процессом notepad (notepad.exe), будет обозначен как "\Process(notepad)\% Processor Time". В случае нескольких экземпляров одного и того же процесса появляется знак #, за которым следует номер экземпляра. Например, если MyApp.exe запущен дважды, будут указаны "MyApp" и "MyApp#1" (подробнее об этом позже).</p>

<p class="justify-style">Какие образцы данных можно получить таким образом? Мы упомянем лишь некоторые из них, чтобы показать богатство предоставленной информации:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style">Как использование CPU распределяется между ядром системы и программами (Processor/% Privileged Time, Processor/% User Time)</p>
    </li>
    <li>
        <p class="justify-style">В какой степени отдельные процессы потребляют ресурсы CPU (Process/% Processor Time)</p>
    </li>
    <li>
        <p class="justify-style">В какой степени и как отдельные процессы используют память (Process/Working Set, Process/Working Set - Private, Process/Private Bytes)</p>
    </li>
    <li>
        <p class="justify-style">Как используется жесткий диск (Process/IO Read Bytes/sec, Process/IO Write Bytes/sec, Process/Page Faults/sec)</p>
    </li>
    <li>
        <p class="justify-style">Сколько операций записи/чтения на диск находится в очереди (PhysicalDisk/Current Disk Queue Length)</p>
    </li>
    <li>
        <p class="justify-style">Сколько исключений генерирует приложение .NET (.NET CLR Exceptions/# of Exceps Thrown/sec)</p>
    </li>
</ul>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Счетчики производительности в категориях «.NET» доступны только для .NET Framework. Их эквивалент для .NET Core описан в следующем разделе.</p>
  </div>
</div>

<p class="justify-style">Конечно, вас в первую очередь интересует категория .NET CLR Memory, где можно найти следующие счетчики (орфография и регистры символов сохранены без изменений):</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"># Bytes in all Heaps</p>
    </li>
    <li>
        <p class="justify-style"># GC Handles</p>
    </li>
    <li>
        <p class="justify-style"># Gen 0 Collections, # Gen 1 Collections, # Gen 2 Collections</p>
    </li>
    <li>
        <p class="justify-style"># Induced GC</p>
    </li>
    <li>
        <p class="justify-style"># of Pinned Objects</p>
    </li>
    <li>
        <p class="justify-style"># of Sink Blocks in use</p>
    </li>
    <li>
        <p class="justify-style"># Total committed Bytes, # Total reserved Bytes</p>
    </li>
    <li>
        <p class="justify-style">% Time in GC</p>
    </li>
    <li>
        <p class="justify-style">Allocated Bytes/sec</p>
    </li>
    <li>
        <p class="justify-style">Finalization Survivors</p>
    </li>
    <li>
        <p class="justify-style">Gen 0 heap size, Gen 1 heap size, Gen 2 heap size, Large Object Heap Size</p>
    </li>
    <li>
        <p class="justify-style">Gen 0 Promoted Bytes/Sec, Gen 1 Promoted Bytes/Sec</p>
    </li>
    <li>
        <p class="justify-style">Process ID</p>
    </li>
    <li>
        <p class="justify-style">Promoted Finalization-Memory from Gen 0</p>
    </li>
    <li>
        <p class="justify-style">Promoted Memory from Gen 0, Promoted Memory from Gen 1</p>
    </li>
</ul>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Названия этих счетчиков производительности (как и других в категориях .NET CLR) переводятся на активный язык операционной системы, поэтому на вашем компьютере или сервере могут быть указаны другие названия и категории. Это может быть довольно раздражающим, поскольку во многих переводах эти названия звучат немного странно. Это одна из многих причин, по которым мы рекомендовали бы вам использовать английский язык как основной язык Windows.</p>
  </div>
</div>

<p class="justify-style">Если тема сборки мусора (Garbage Collection) вам хотя бы немного знакома, вы, вероятно, уже догадались о значении большинства из упомянутых выше счетчиков. Вы будете встречать их на протяжении всей остальной части книги. Уже сейчас можно сказать, что это полный набор данных, позволяющий глубоко понять состояние вашего приложения.</p>

<p class="justify-style">Расчет счетчиков синхронизирован с жизненным циклом сборки мусора. В частности, большинство измерений производится в начале или в конце процесса GC. В этом смысле счетчики производительности могут предоставлять очень ценную и точную информацию. Однако есть несколько важных замечаний, которые стоит упомянуть в этом контексте:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style">Чтение значений счетчиков производительности полностью зависит от частоты, с которой используемый вами инструмент выполняет их выборку. Если выборка происходит достаточно часто (например, каждую секунду), данные будут полностью точными. Однако если выборка редкая, результаты могут быть ошибочными и вводить в заблуждение. Например, если не повезет и полная сборка мусора (тот, который потребляет больше всего ресурсов) будет происходить непосредственно перед каждым вашим измерением, вы получите ложное представление о том, сколько времени тратится на GC (% Time in GC). Другими словами, при анализе счетчиков производительности следует внимательно следить за способом выборки данных.</p>
    </li>
    <li>
        <p class="justify-style">Данные счетчиков производительности обновляются только при возникновении определенных событий (в основном начала и окончания сборки мусора), после чего их значения остаются неизменными. Это может привести к неверным показаниям. Предположим, например, что в вашем процессе недавно произошла полная сборка мусора, во время которой % Time in GC составил 50%. С этого момента счетчик % Time in GC будет показывать высокое значение 50%, даже если наблюдаемый процесс больше не выполняет никакой работы. Пока не начнется новая сборка мусора, эти значения не будут обновлены. Другими словами, при наблюдении за счетчиками следует уделять больше внимания изменениям, а не текущим значениям. Наблюдаемое значение — это просто последнее измеренное значение.</p>
    </li>
</ul>

<p class="justify-style">Microsoft с версии .NET Framework 4.0 предпочитает использование событий ETW (описано в следующем разделе) для передачи значимой полезной нагрузки вместо счетчиков производительности. Однако использование инструментов счетчиков производительности намного проще, чем любых инструментов, связанных с ETW. Мы подробно рассмотрим различия между измерениями счетчиков производительности и ETW в пятой главе.</p>

<p class="justify-style">Множество инструментов мониторинга используют счетчики производительности, поскольку это очень легковесный и эффективный способ получения большого объема информации. Однако одним из самых простых и часто используемых инструментов является встроенный Windows Performance Monitor. Запустить его можно с помощью команды <span class="fw-bold fst-italic">perfmon.exe</span> или через поиск в меню "Пуск".</p>

<p class="justify-style">Затем выберите пункт <span class="fw-bold fst-italic">Performance ➤ Monitoring Tools ➤ Performance Monitor</span> в левом меню. В появившемся графике, в контекстном меню выберите опцию <span class="fw-bold fst-italic">Add Counters...</span> (см. <a href="#f-3-9">рисунок 3-9</a>).</p>

<figure id="f-3-9" class="figure">
    <img src="content/img/3-9.png" class="img-fluid" alt="Рисунок 3-9" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-9. Монитор производительности – общий вид с опцией контекста «Добавить счетчики»</figcaption>
</figure>

<p class="justify-style">Используйте диалоговое окно для выбора интересующей категории (в нашем случае это память .NET CLR), а также конкретных счетчиков и экземпляров (см. <a href="#f-3-10">рисунок 3-10</a>).</p>

<figure id="f-3-10" class="figure">
    <img src="content/img/3-10.png" class="img-fluid" alt="Рисунок 3-10" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-10. Монитор производительности – диалоговое окно «Добавить счетчики»</figcaption>
</figure>

<p class="justify-style">После добавления счетчиков часто требуется время, чтобы адаптировать диаграммы к своим потребностям. Речь идет в первую очередь о</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style">Масштабирование каждого графика (щелчок правой кнопкой мыши, Масштаб выбранных счетчиков)</p>
    </li>
    <li>
        <p class="justify-style">Частота и количество выборок (Ctrl+L, вкладка Общие, Выборка каждый и Параметры длительности)</p>
    </li>
    <li>
        <p class="justify-style">Вертикальный масштаб графика (Ctrl+L, вкладка График, Минимальный и Максимальный параметры вертикального масштаба)</p>
    </li>
    <li>
        <p class="justify-style">Способ прокрутки графика (Ctrl+L, вкладка График, параметр Стиль прокрутки)</p>
    </li>
</ul>

<p class="justify-style">Правильно выбрав указанные выше параметры (и, возможно, выбрав толщину и цвет каждого ряда данных), вы можете настроить график под краткосрочный анализ или наблюдать за ежедневными тенденциями. Примеры на <a href="#f-3-11">рисунке 3-11</a> и <a href="#f-3-12">рисунке 3-12</a> иллюстрируют это.</p>

<figure id="f-3-11" class="figure">
    <img src="content/img/3-11.png" class="img-fluid" alt="Рисунок 3-11" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-11. Performance Monitor — анализ короткого периода (100 секунд) с видимыми размерами генерации GC</figcaption>
</figure>

<figure id="f-3-12" class="figure">
    <img src="content/img/3-12.png" class="img-fluid" alt="Рисунок 3-12" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-12. Performance Monitor — долгосрочный анализ (50 минут) с видимыми размерами генерации GC</figcaption>
</figure>

<p class="justify-style">Механизм счетчиков производительности имеет одно раздражающее свойство, с которым вам придется научиться мириться. Как уже упоминалось, каждый процесс, публикующий счетчики под одним и тем же именем, имеет уникальное имя экземпляра, которое соответствует имени процесса. Например, веб-приложение, размещенное на IIS, будет иметь счетчик \.NET CLR Memory(w3wp)\# Bytes in all Heaps (так как приложения пула приложений запускаются в процессе w3wp.exe). Однако если несколько приложений размещены в разных пулах приложений, появится несколько экземпляров, пронумерованных последовательно, например, w3wp, w3wp#1, w3wp#2 и т.д. Как узнать, какой экземпляр соответствует какому пулу приложений? Счетчик .NET CLR Memory/Process ID придет на помощь: он покажет PID каждого процесса экземпляра. Но будьте внимательны! Именно здесь начинается раздражающая часть — соответствие между процессом и экземпляром счетчика производительности может меняться со временем! Если, например, один из пулов приложений останавливается (из-за не активности или по другой причине), оставшиеся процессы изменят свое соответствие экземплярам (см. <a href="#t-3-1">Таблицу 3-1</a>).</p>

<figure id="t-3-1" class="figure">
    <table class="table table-striped table-hover border-1 ">
      <thead>
        <tr>
          <th scope="col">#</th>
          <th scope="col">До остановки процесса с PID 11200</th>
          <th Scope="col">После остановки процесса с PID 11200</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="row">1</th>
          <td>экземпляр w3wp представляет PID11200</td>
          <td>экземпляр w3wp имеет PID 8710</td>
        </tr>
        <tr>
          <th scope="row">2</th>
          <td>экземпляр w3wp#1 представляет PID 8710</td>
          <td>экземпляр w3wp#1 представляет PID 10410</td>
        </tr>
        <tr>
          <th scope="row">3</th>
          <td>экземпляр w3wp#2 имеет PID 10410</td>
          <td></td>
        </tr>        
      </tbody>
    </table>
    <figcaption class="figure-caption">Таблица 3-1. Проблема с динамическим переименованием экземпляров пула приложений</figcaption>
  </figure>

<p class="justify-style">Это очень раздражает, особенно если вы хотите создать, например, автоматический механизм для наблюдения за определенными пулами приложений. В таком случае важно убедиться, что такие события, как автоматическая остановка пула приложений, вообще не происходят. С аналогичным механизмом вы также можете столкнуться, если в IIS включена опция перезапуска пула приложений с наложением (overlapping). В этом случае некоторое время будут существовать два экземпляра одного и того же счетчика, поэтому переопределение экземпляров неизбежно.</p>

<p class="justify-style">Из-за вышеупомянутого неочевидного соответствия, в случае ручного наблюдения за приложениями, размещенными на IIS, наиболее распространенный сценарий выглядит следующим образом: проверьте текущий PID пула приложений, который вас интересует, и найдите экземпляр w3wp, у которого есть соответствующий счетчик .NET CLR Memory/Process ID. Затем добавьте счетчики именно этого экземпляра.</p>

<p class="justify-style">Альтернативно, вы можете обновить значение ключа реестра <span class="fw-bold fst-italic">ProcessNameFormat</span> в разделе <span class="fw-bold fst-italic">HKLM\System\CurrentControlSet\Services\.NETFramework\Performance</span>. Если установить его в 2, формат имен экземпляров изменится на <code class="fs-6 fst-italic">&lt;processName&gt;_&lt;pid&gt;</code>, что значительно упрощает управление. Однако это изменение будет применяться ко всей системе, поэтому оно может вызвать проблемы с совместимостью некоторых инструментов.</p>

<p class="justify-style">Многие другие программы используют счетчики производительности, но остановимся здесь. Мы будем использовать Performance Monitor для демонстрации работы сборщика мусора в действии на Windows.</p>

<hr class="border-2">
<p id="chapter3-2-4" class="h4 p-2">Счетчики .NET Core</p>

<p class="justify-style">С момента своего создания .NET Core должен был поддерживать несколько платформ, а не только Windows. Вот почему выдача метрик в виде счетчиков производительности Windows невозможна. Microsoft предоставляет новый набор инструментов интерфейса командной строки (CLI), включая dotnet-counters для прослушивания счетчиков CLR. Другие полезные инструменты CLI будут описаны позже, но все они могут быть установлены двумя разными способами:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style">Загрузите двоичный файл непосредственно с их веб-страницы по адресу <a href="https://learn.microsoft.com/en-us/dotnet/core/diagnostics/" target="_blank">https://learn.microsoft.com/en-us/dotnet/core/diagnostics/</a>. Выбираете правильную ссылку, соответствующую вашей ОС и платформе. Это позволяет вам создавать скрипты для установки инструмента в ваших контейнерах, например, благодаря curl.</p>
    </li>
    <li>
        <p class="justify-style">На вашей машине разработчика или любой машине с установленным .NET SDK вы можете установить любой инструмент CLI с помощью команды <code class="fs-6 fw-bold fst-italic">dotnet tool install -g &lt;tool name&gt;</code>. Например, <code class="fs-6 fw-bold fst-italic">dotnet tool install -g dotnet-counters</code> устанавливает последнюю версию dotnet-counters. Если вы хотите обновиться до последней версии, используйте <code class="fs-6 fw-bold fst-italic">dotnet tool update -g dotnet-counters</code>.</p>
    </li>
</ul>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">После установки dotnet-counters с помощью dotnet install вы можете начать его использовать, но вместо ввода dotnet-counters в командной строке используйте dotnet counters без "-". Эта функция псевдонимов работает для всех инструментов CLI.</p>
  </div>
</div>

<p class="justify-style">Вернемся к dotnet-counters. Прежде всего, вам нужно определиться, в каких счетчиках вы заинтересованы. Команда list помогает вам, перечисляя доступные счетчики для каждого поставщика счетчиков. Понятие поставщика счетчиков близко к категории счетчиков производительности Windows.</p>

<p class="justify-style">Базовые счетчики CLR предоставляются поставщиком счетчиков System.Runtime:</p>

<figure id="dotnet-counters-list" class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cpp">
C:\> dotnet counters list
Showing well-known counters for .NET (Core) version 6.0 only. Specific processes may support 
additional counters.
System.Runtime
    cpu-usage                           The percent of process' CPU usage relative to all of 
                                        the system CPU resources [0-100]
    working-set                         Amount of working set used by the process (MB)
    gc-heap-size                        Total heap size reported by the GC (MB)
    gen-0-gc-count                      Number of Gen 0 GCs between update intervals
    gen-1-gc-count                      Number of Gen 1 GCs between update intervals
    gen-2-gc-count                      Number of Gen 2 GCs between update intervals
    time-in-gc                          % time in GC since the last GC
    gen-o-size                          Gen O Heap Size
    gen-l-size                          Gen 1 Heap Size
    gen-2-size                          Gen 2 Heap Size
    Ioh-size                            LOH Size
    poh-size                            POH (Pinned Object Heap) Size
    alloc-rate                          Number of bytes allocated in the managed heap between
                                        update intervals
    gc-fragmentation                    GC Heap Fragmentation
    assembly-count                      Number of Assemblies Loaded
    exception-count                     Number of Exceptions / sec
    threadpool-thread-count             Number of ThreadP001 Threads
    monitor-lock-contention-count       Number of times there were contention when trying to
                                        take the monitor lock between update intervals
    threadpool-queue-length             ThreadP001 Work Items Queue Length
    threadpool-completed-items-count    ThreadP001 Completed Work Items Count
    active-timer-count                  Number of timers that are currently active
    il-bytes-jitted                     Total IL bytes jitted
    methods-jitted-count                Number of methods jitted
    gc-committed                        Size of committed memory by the GC (MB)
            </code>
        </div>
    </pre>
    <figcaption class="figure-caption">Пример консольного вывода команды list. Вывод списка доступных счётчиков.</figcaption>
  </figure>

<p class="justify-style">Вы можете узнать большинство счетчиков производительности Windows, которые были перечислены ранее, а также несколько новых, которые будут рассмотрены в последующих главах. Кроме того, другие компоненты .NET предоставляют свои собственные счетчики, такие как Microsoft.AspNetCore.Hosting для статистики запросов; Microsoft-AspNetCore-Server-Kestrel для низкоуровневых метрик соединений; System.Net.Http для соединений и метрик запросов; System.Net.NameResolution для подробностей поиска DNS; System.Net.Sockets для низкоуровневой информации о соединениях, байтах и ​​датаграммах; или System.Net.Security для метрик TLS и сеансов.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Эти поставщики жестко запрограммированы в dotnet-counters и могут отличаться в зависимости от версии CLR, в которой работает ваше приложение.</p>
  </div>
</div>

<p class="justify-style">Как только вы узнаете, какие счетчики вам интересны, вы можете использовать параметр --counters, чтобы передать их в dotnet-counters. Если вам нужны все счетчики поставщика счетчиков, просто укажите имя поставщика. Если вас интересует только подмножество счетчиков, перечислите их между []:</p>

<p class="justify-style"><code class="fs-5 fw-bold fst-italic">--counters System.Runtime[gc-heap-size,loh-size, gen-2-size]</code></p>

<p class="justify-style">Затем вам нужно узнать идентификатор процесса, который вы хотите отслеживать. Команда <code class="fs-5 fw-bold fst-italic">ps</code> может вам помочь: она выводит список всех приложений, работающих с .NET Core, включая себя (т. е. dotnet) с соответствующим pid, именем процесса, исполняемым путем и командной строкой:</p>

<figure id="dotnet-counters-ps" class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cpp">
C:\> dotnet counters ps
    84716  dotnet  C:\Program Files\dotnet\dotnet.exe    counters ps
            </code>
        </div>
    </pre>
    <figcaption class="figure-caption">Пример консольного вывода команды ps. Вывод списка всех приложений, работающих с .NET Core.</figcaption>
  </figure>

<p class="justify-style">Как только у вас есть идентификатор процесса, передайте его через параметр -p.</p>

<p class="justify-style">Доступны два различных режима использования. Как показано на <a href="#f-3-13">рисунке 3-13</a>, при использовании monitor счетчики отображаются в консоли и их значение обновляется каждую секунду (если вы хотите менее частые обновления, используйте параметр --refresh-interval с частотой в секундах).</p>

<figure id="f-3-13" class="figure">
    <img src="content/img/3-13.png" class="img-fluid" alt="Рисунок 3-13" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-13. dotnet counters monitor — обновление значений различных счетчиков</figcaption>
</figure>

<p class="justify-style">Этот режим не особо полезен, за исключением разве что демонстраций во время конференций.</p>

<p class="justify-style">На самом деле вам нужен способ записи значений счетчиков с течением времени и анализа эволюции или пиков, как это делается с помощью Performance Monitor. Это то, что предоставляет второй режим сбора: выбранные счетчики (по умолчанию System.Runtime) будут периодически собираться и сохраняться в файле, указанном через параметр -o (или counter по умолчанию). По умолчанию файл сохраняется в формате CSV, но вы можете переключиться на json с помощью --format json.</p>

<p class="justify-style">Наконец, вы можете использовать параметр --duration, чтобы задать продолжительность сбора данных в секундах.</p>

<p class="justify-style">Visual Studio обеспечивает графическую визуализацию счетчиков .NET с течением времени при запуске сеанса профилирования производительности, как показано на <a href="#f-3-14">рисунке 3-14</a>.</p>

<figure id="f-3-14" class="figure">
    <img src="content/img/3-14.png" class="img-fluid" alt="Рисунок 3-14" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-14. Отображение счетчиков .NET в сеансе профилирования Visual Studio</figcaption>
</figure>

<p class="justify-style">Если вам нужен визуальный кроссплатформенный инструмент, Конрад Кокоса реализовал его для вас! Более подробную информацию можно найти на сайте <a href="https://github.com/kkokosa/dotnet-counters-ui" target="_blank">https://github.com/kkokosa/dotnet-counters-ui</a>.</p>

<hr class="border-2">
<p id="chapter3-2-5" class="h4 p-2">Трассировка событий для Windows</p>

<p class="justify-style">Среди различных доступных диагностических инструментов некоторые из самых мощных основаны на механизме, называемом <span class="fw-bold fst-italic">Event Tracing for Windows (ETW)</span>. К сожалению, этот механизм, кажется, немного недооценен. Возможно, это связано с тем, что он развивался постепенно на протяжении многих лет и еще не получил заслуженного внимания. ETW существует с момента выпуска Windows 2000, но с каждой новой версией системы становится доступно все больше данных. Он был значительно развит в Windows Vista и Windows Server 2003. В Windows 7 была добавлена ключевая возможность сохранять стек вызовов вместе с каждым событием (см. <a href="https://learn.microsoft.com/en-gb/windows/win32/etw/what-s-new-in-event-tracing" target="_blank">https://learn.microsoft.com/en-gb/windows/win32/etw/what-s-new-in-event-tracing</a> ).</p>

<p class="justify-style">Сила ETW заключается в предоставлении огромных объемов информации с очень низкими накладными расходами — обычно менее нескольких процентов дополнительного потребления ресурсов ЦП. Благодаря этому его можно использовать в производственных системах без каких-либо проблем. Его можно включать и выключать во время работы приложений, без необходимости их перезапуска. Многие инструменты извлекают пользу из ETW. Вы можете даже не знать, сколько из них. Например, известный Event Log, его браузер (eventvwr.exe) и Resource Monitor (resmon.exe) построены поверх ETW. Однако механизм счетчика производительности, описанный в предыдущем разделе, не основан на Event Tracing для Windows.</p>

<p class="justify-style">Прежде чем перейти к описанию конкретных инструментов, неплохо было бы ознакомиться с общей архитектурой этого механизма. Важно понимать различные понятия, связанные с ETW:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Событие ETW</span>: отдельное событие, которое может быть зарегистрировано любым компонентом системы.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Сеанс ETW</span>: Центральная часть всего механизма, сеанс создается инструментом для получения доступа к зарегистрированным событиям. Технически это набор системных ресурсов, таких как буферы в памяти и потоки для записи на диск (см. <a href="#f-3-15">Рисунок 3-15</a>).</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Поставщик ETW</span>: Каждый пользовательский компонент или компонент режима ядра, который доставляет события. Существует множество встроенных системных провайдеров, сгруппированных по категориям, таким как сетевые провайдеры, процессы и т.д. Это также включает среду выполнения .NET и ваш код (если вы хотите опубликовать свои пользовательские события ETW). Поставщики идентифицируются по глобальному уникальному идентификатору (GUID).</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Контроллер ETW</span>: Процесс, отвечающий за создание сеанса и его подключение к выбранным поставщикам.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Потребитель ETW</span>: Любое средство, которое потребляет события, иногда сохраняя их в так называемых файлах журнала трассировки событий (ETL).</p>
    </li>
</ul>

<p class="justify-style">Сеанс трассировки событий Windows рассчитан на минимально возможные накладные расходы (см. <a href="#f-3-15">рис. 3-15</a> ). С точки зрения процесса, отправка события — это просто быстрое действие, включающее неблокирующую запись в очередь (в буфере памяти), поддерживаемую на уровне ядра. Затем выделенный поток ядра обрабатывает эти очереди и записывает события в определенные цели — обычно в файл или какой-либо другой буфер в памяти (для проведения анализа в реальном времени)</p>

<figure id="f-3-15" class="figure">
    <img src="content/img/3-15.png" class="img-fluid" alt="Рисунок 3-15" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-15. Трассировка событий для внутренних компонентов Windows</figcaption>
</figure>

<p class="justify-style">Концептуально один и тот же поставщик может предоставлять информацию нескольким сеансам (см. <a href="#f-3-16">рисунок 3-16</a>). И наоборот, сеанс может получать информацию от нескольких поставщиков. Характерной чертой ETW является работа на уровне поставщиков, а не процессов. Чтобы получить информацию от одного или нескольких поставщиков, с помощью контроллера вы создаете новый сеанс, к которому вы их подключаете. Как только сеанс начнется, все процессы в системе, реализующие этого провайдера, будут регистрировать события в вашем сеансе: вы будете собирать события для всей машины, а не из конкретного процесса. Потребители должны фильтровать данные по интересующим их процессам.</p>

<figure id="f-3-16" class="figure">
    <img src="content/img/3-16.png" class="img-fluid" alt="Рисунок 3-16" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-16. Стандартные блоки трассировки событий Windows (ETW), иллюстрирующие различные возможности конфигурации. Обратите внимание, что процесс может содержать несколько поставщиков трассировки событий Windows; Таким образом, некоторые процессы перечисляются несколько раз</figcaption>
</figure>

<p class="justify-style">Удержание событий в буферах вне процесса приложения имеет еще одно преимущество — сбой приложения не приведет к потере каких-либо диагностических данных. Конечно, при регистрации большого количества событий доступ к диску может стать узким местом и создать накладные расходы для всей машины. Однако вы столкнетесь с этой ситуацией только тогда, когда включите слишком много интенсивно используемых поставщиков для своего сеанса. Когда вы просите ETW отправить данные в файл, другим риском может быть исчерпание дискового пространства, но решение существует. Вы можете записывать данные в файл в режиме кольцевого буфера, поэтому вам не придется беспокоиться о переполнении диска. Данные будут циклически перезаписываться в буфере фиксированного размера. Наиболее типичный сценарий — запустить сеанс, сохраняющий данные в кольцевом буфере, и дождаться определенного сценария. Только после этого вы закрываете сеанс и сохраняете данные из буфера в файл.</p>

<p class="justify-style">Начиная с Windows 7, можно собирать трассировку стека, связанную с событиями ядра и пользователя. Полезная нагрузка этих событий (в паре с исходными событиями) — это указатель инструкций каждого кадра стека. Потребитель должен разрешить эти указатели инструкций в имена методов, обычно на этапе анализа. Однако это применимо к машинному коду (т. е. также к коду CLR), но не к управляемому коду до Windows 8.</p>

<p class="justify-style">Встроенное событие выборки CPU ETW позволяет нам, например, отслеживать проблемы с высокой загрузкой CPU. Для каждого события выборки (генерируемого каждую миллисекунду) стек вызовов всех потоков, запланированных на ядре, собирается из всех процессов. Благодаря этому статистически можно увидеть причину проблемы с привязкой к CPU — на какие функции было потрачено больше всего времени. При поддержке поставщиков ОС можно также отслеживать проблемы синхронизации (например, взаимоблокировки). Например, он используется плагином Concurrency Visualizer для Visual Studio.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Для большинства диагностических инструментов в среде Windows вам необходим доступ к файлам символов (PDB – Program Database), которые позволяют декодировать информацию о методах из стеков вызовов. Наиболее удобная настройка – переменная среды _NT_SYMBOL_PATH, в которой вы указываете расположение символов. Обычно это комбинация локальной папки (для кэширования) и адреса публичного сервера символов Microsoft:</p>
    <p class="card-text justify-style"></p><span class="fw-bold fst-italic">srv*C:\Symbols*https://msdl.microsoft.com/download/symbols</span></p>
    <p class="card-text justify-style"></p>Это позволяет нам получать PDB-файлы операционной системы Windows и библиотеки CLR. Visual studio и WinDbg – два примера инструментов, которые используют эту переменную среды.</p>
  </div>
</div>

<p class="justify-style">Существует специальный сеанс <span class="fw-bold fst-italic">NT Kernel Logger</span>, который может использоваться только с поставщиками уровня ядра, из которых, например, можно получить начало и конец любого процесса. Поставщик пользователя Microsoft-Windows-TCPIP — еще один пример, который регистрирует события из драйвера режима ядра tcpip.sys.</p>

<p class="justify-style">Операционная система предоставляет много интересной информации, такой как управление процессами и потоками, сетевые функции, операции ввода-вывода и т. д. Но больше всего нас интересует то, что CLR имеет собственных поставщиков ETW, предоставляющих большой объем информации о среде выполнения в контексте вашего приложения.</p>

<p class="justify-style">Вы можете использовать встроенную утилиту logman.exe для поиска всех поставщиков, связанных с .NET, в системе (см. <a href="#l-3-1">листинг 3-1)</a>.</p>

<figure id="l-3-1" class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cpp">
<b>C:\> logman query providers | findstr DotNET</b>
Microsoft-Windows-DotNETRuntime          {E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}
Microsoft-Windows-DotNETRuntimeRundown   {A669021C-C450-4609-A035-5AF59AF4DF18}
            </code>
        </div>
    </pre>
    <figcaption class="figure-caption">Листинг 3-1. Использование утилиты logman для составления списка всех поставщиков ETW, связанных с .NET</figcaption>
</figure>

<p class="justify-style">Вы также можете использовать logman, чтобы узнать, какие поставщики доступны в контексте определенного процесса. Например, если вы спросите об ASP.NET WebAPI, размещенном на IIS, вы получите список, как в <a href="#l-3-2">Листинге 3-2</a> (результат представляет только некоторых из многих перечисленных поставщиков).</p>

<figure id="l-3-2" class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cpp">
<b>C:\> logman query providers -pid 6228</b>
Provider                                 GUID
--------------------------------------------------------------------------
<b>.NET Common Language Runtime             {E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}</b>
ASP.NET Events                           {AFF081FE-0247-4275-9C4E-021F3DC1DA35}
IIS: WWW Global                          {D55D3BC9-CBA9-44DF-827E-132D3A4596C2}
IIS: WWW Isapi Extension                 {A1C2040E-8840-4C31-BA11-9871031A19EA}
IIS: WWW Server                          {3A2A4E84-4C21-4981-AE10-3FDA0D9B0F83}
Microsoft-Windows-Application            {C651F5F6-1C0D-492E-8AE1-B4EFD7C9D503}
Server-Applications                      
Microsoft-Windows-Application-Experience {EEF54E71-0661-422D-9A98-82FD4940B820}
<b>Microsoft-Windows-DotNETRuntimeRundown   {A669021C-C450-4609-A035-5AF59AF4DF18}</b>
Microsoft-Windows-IIS                    {DE4649C9-15E8-4FEA-9D85-1CDDA520C334}
Microsoft-Windows-IIS-Configuration      {DC0B8E51-4863-407A-BC3C-1B479B2978AC}
...
            </code>
        </div>
    </pre>
    <figcaption class="figure-caption">Листинг 3-2. Использование утилиты logman для составления списка всех поставщиков ETW данного процесса ASP.NET</figcaption>
</figure>

<p class="justify-style">Если вы спросите о консольном приложении, работающем на .NET Core, то вы получите немного другой набор поставщиков (см. <a href="#l-3-3">Листинг 3-3</a>).</p>

<figure id="l-3-3" class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cli">
<b>C:\> logman query providers -pid 8528</b>
Provider                                 GUID
--------------------------------------------------------------------------
<b>.NET Common Language Runtime             {E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}</b>
Microsoft-Windows-AsynchronousCausality  {19A4C69A-28EB-4D4B-8D94-5F19055A1B5C}
Microsoft-Windows-COM-Perf               {B8D6861B-D20F-4EEC-BBAE-87E0DD80602B}
Microsoft-Windows-Crypto-BCrypt          {C7E089AC-BA2A-11E0-9AF7-68384824019B}
Microsoft-Windows-Crypto-RSAEnh          {152FDB2B-6E9D-4B60-B317-815D5F174C4A}
<b>Microsoft-Windows-DotNETRuntimeRundown   {A669021C-C450-4609-A035-5AF59AF4DF18}</b>
Microsoft-Windows-Networking-Correlation {83ED54F0-4D48-4E45-B16E-726FFD1FA4AF}
Microsoft-Windows-Shell-Core             {30336ED4-E327-447C-9DE0-51B652C86108}
Microsoft-Windows-User-Diagnostic        {305FC87B-002A-5E26-D297-60223012CA9C}
Microsoft-Windows-WinRT-Error            {A86F8471-C31D-4FBC-A035-665D06047B03}
{012616AB-FF6D-4503-A6F0-EFFD0523ACE6}   {012616AB-FF6D-4503-A6F0-EFFD0523ACE6}
{05F95EFE-7F75-49C7-A994-60A55CC09571}   {05F95EFE-7F75-49C7-A994-60A55CC09571}
...
            </code>
        </div>
    </pre>
    <figcaption class="figure-caption">Листинг 3-3. Использование утилиты logman для составления списка всех поставщиков ETW данного процесса .NET Core</figcaption>
</figure>

<p class="justify-style">Как вы можете видеть, поставщики, связанные с .NET, имеют одинаковый GUID в .NET Framework и приложении .NET Core. Если вам не повезло и вы все еще используете .NET Core 2.1 или более раннюю версию, вы также заметите, что есть два имени для одного и того же поставщика, которые используются взаимозаменяемо: Microsoft-Windows-DotNETRuntime также называется .NET Common Language Runtime.</p>

<p class="justify-style">Каждое событие ETW, создаваемое в рамках данного поставщика, имеет несколько важных атрибутов:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Id</span>: Уникальный идентификатор события.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Version</span>: Используется для управления версиями событий.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Keyword</span>: Битовая маска, используемая для присвоения одного или нескольких значений (ключевых слов) событию.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Level</span>: Уровень ведения журнала.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Opcode</span>: Под ним подразумевается конкретное действие (этап) в рамках данного события. Наиболее часто используемыми встроенными значениями являются коды операций Start и End.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Task</span>: Он используется для группировки событий от поставщика по определенным функциям.</p>
    </li>
</ul>

<p class="justify-style">С помощью инструмента logman вы также можете узнать подробности о конкретном провайдере. Для основного провайдера .NET ETW вы получите информацию, как в <a href="#l-3-4">листинге 3-4</a>.</p>

<figure id="l-3-4" class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cli">
C:\> logman query providers "Microsoft-Windows-DotNETRuntime"
Provider                                GUID
--------------------------------------------------------------------------
Microsoft-Windows-DotNETRuntime         {E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}
Value               Keyword             Description
--------------------------------------------------------------------------
0x0000000000000001  GCKeyword           GC
0x0000000000000002  GCHandleKeyword     GCHandle
0x0000000000000004  FusionKeyword       Binder
0x0000000000000008  LoaderKeyword       Loader
0x0000000000000010  JitKeyword          Jit
0x0000000000000020  NGenKeyword         NGen
0x0000000000000040  StartEnumerationKeyword StartEnumeration
0x0000000000000080  EndEnumerationKeyword StopEnumeration
0x0000000000000400  SecurityKeyword     Security
0x0000000000000800  AppDomainResourceManagementKeyword AppDomainResourceManagement
0x0000000000001000  JitTracingKeyword   JitTracing
0x0000000000002000  InteropKeyword      Interop
0x0000000000004000  ContentionKeyword   Contention
0x0000000000008000  ExceptionKeyword    Exception
0x0000000000010000  ThreadingKeyword    Threading
0x0000000000020000  JittedMethodILToNativeMapKeyword JittedMethodILToNativeMap
0x0000000000040000  OverrideAndSuppressNGenEventsKeyword OverrideAndSuppressNGenEvents
0x0000000000080000  TypeKeyword         Type
0x0000000000100000  GCHeapDumpKeyword   GCHeapDump
0x0000000000200000  GCSampledObjectAllocationHighKeyword GCSampledObjectAllocationHigh
0x0000000000400000  GCHeapSurvivalAndMovementKeyword GCHeapSurvivalAndMovement
0x0000000000800000  GCHeapCollectKeyword GCHeapCollect
0x0000000001000000  GCHeapAndTypeNamesKeyword GCHeapAndTypeNames
0x0000000002000000  GCSampledObjectAllocationLowKeyword GCSampledObjectAllocationLow
0x0000000020000000  PerfTrackKeyword    PerfTrack
0x0000000040000000  StackKeyword        Stack
0x0000000080000000  ThreadTransferKeyword ThreadTransfer
0x0000000100000000  DebuggerKeyword     Debugger
0x0000000200000000  MonitoringKeyword   Value
Level               Monitoring         Description
--------------------------------------------------------------------------
0x00                win:LogAlways      Log Always
0x02                win:Error          Error
0x04                win:Informational  Information
0x05                win:Verbose        Verbose
...
followed by the list of processes containing this provider.
            </code>
        </div>
    </pre>
    <figcaption class="figure-caption">Листинг 3-4. Получение сведений о поставщике .NET ETW</figcaption>
</figure>

<p class="justify-style">Например, для списка событий, сгенерированных поставщиками .NET, вы можете использовать документацию Microsoft по адресу <a href="https://learn.microsoft.com/en-us/dotnet/framework/performance/clr-etw-events" target="_blank">https://learn.microsoft.com/en-us/dotnet/framework/performance/clr-etw-events</a>. Однако не все события документированы. Поэтому лучше посмотреть на источник, а точнее на файл манифеста данного поставщика. Файл манифеста ETW определяет строго типизированную информацию о событиях, сгенерированную для данного поставщика. Это позволяет потребителю правильно интерпретировать записанные данные сеанса. Файлы манифеста различны для каждой версии среды выполнения .NET. Вы можете найти их в разных местах:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style">Для .NET Core, в .\runtime\src\coreclr\vm\ClrEtwAll.man в github</p>
    </li>
    <li>
        <p class="justify-style">Для .NET Framework 4.0 и более поздних версий, в c:\Windows\Microsoft.NET\Framework64\v4.0.30319\CLR-ETW.man</p>
    </li>
    <li>
        <p class="justify-style">Для .NET Framework 2.0 и более ранних версий он недоступен, так как они не поддерживают ETW.</p>
    </li>
</ul>

<p class="justify-style">Когда вы посмотрите на этот файл, вы найдете полное описание поставщиков Microsoft-WindowsDotNETRuntime и Microsoft-Windows-DotNETRuntimeRundown. Этот файл — настоящий кладезь знаний, если вы хотите использовать поставщиков .NET ETW. Давайте кратко рассмотрим события, которые выдают оба поставщика. Мы вернемся ко всем этим событиям в следующих главах этой книги, чтобы вы имели полное представление о каждом из них. Однако сначала мы сосредоточимся здесь на самых интересных. Это позволит вам увидеть, насколько богата информация, предоставляемая поставщиками .NET ETW. Не беспокойтесь о Linux, те же события (и даже больше) выдаются .NET Core через кроссплатформенный канал связи EventPipe.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Рассмотрение только испускаемых событий может привести к некоторым интересным вопросам. Например, что такое сегмент <span class="fw-bold fst-italic">ReadOnlyHeapMapMessage</span> типа <span class="fw-bold fst-italic">GCSegmentTypeMap?</span> Мы ответим на этот вопрос в Главе 5.</p>
  </div>
</div>

<p class="justify-style">Нас в основном интересуют события, генерируемые поставщиком Microsoft-Windows-DotNETRuntime, сгруппированные в 29 различных задач (как в номенклатуре ETW, атрибут события задачи соответствует ее функциональной категории). Чтобы получить представление о полноте предоставленной информации, эти задачи включают в себя (в скобках показано количество событий данной задачи): AppDomainResourceManagement (5), CLRAuthenticodeVerification CLRILStub (2), CLRLoader (18), CLRMethod (25), CLRPerfTrack (1), CLRRuntimeInformation (1), CLRStack (1), CLRStrongNameVerification (4), Contention (3), Exception (3), ExceptionCatch (2), ExceptionFilter (2), ExceptionFinally (2), GarbageCollection (58), IOThreadCreation (4), IOThreadRetirement (4), Thread (2), ThreadPool (5), ThreadPoolWorkerThread (3) и Type (1).</p>

<p class="justify-style">Как вы можете видеть, самая большая группа — это задача Garbage Collector — она содержит 58 различных событий! На самом деле, их всего 44, поскольку определены разные версии одного и того же события. Вы найдете несколько выбранных событий вместе с описанием и их полезной нагрузкой в <a href="#t-3-2">таблице 3-2</a>.</p>

<figure id="t-3-2" class="figure">
    <table class="table table-striped table-hover border-1 ">
        <thead>
            <tr>
            <th scope="col">#</th>
            <th scope="col">Событие</th>
            <th Scope="col">Данные</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th scope="row">1</th>
                <td>GCStart_V2</td>
                <td>
                    <p class="left-style">ClientSequenceNumber(win:UInt64), ClrInstanceID(win:UInt16),Count(win:UInt32), Depth(win:UInt32), Reason(GCReasonMap), Type(GCTypeMap)</p>
                    <p class="left-style">Сообщает о начале сборки мусора, указывая причину и поколение, вызвавшее ее (в поле Depth)</p>
                </td>
            </tr>
            <tr>
                <th scope="row">2</th>
                <td>GCEnd_V1</td>
                <td>
                    <p class="left-style">ClrInstanceID(win:UInt16), Count(win:UInt32), Depth(win:UInt32)</p>
                    <p class="left-style">Информирует об окончании сборки мусора</p>
                </td>
            </tr>
            <tr>
                <th scope="row">3</th>
                <td>GCCreateSegment_V1</td>
                <td>
                    <p class="left-style">Address(win:UInt64), ClrInstanceID(win:UInt16), Size(win:UInt64), Type(GCSegmentTypeMap)</p>
                    <p class="left-style">Информирует о создании новых сегментов памяти, предоставляя информацию об их размере и типе</p>
                </td>
            </tr>
            <tr>
                <th scope="row">4</th>
                <td>GCSuspendEEBegin_V1</td>
                <td>
                    <p class="left-style">ClrInstanceID(win:UInt16), Count(win:UInt32), Reason(GCSuspendEEReasonMap)</p>
                    <p class="left-style">Информирует о том, когда среда выполнения начинает приостанавливать все потоки приложения в соответствии с требованиями некоторых частей сборки мусора</p>
                </td>
            </tr>
            <tr>
                <th scope="row">5</th>
                <td>GCSuspendEEEnd_V1</td>
                <td>
                    <p class="left-style">ClrInstanceID(win:UInt16)</p>
                    <p class="left-style">Информирует, когда среда выполнения приостановила все потоки приложения</p>
                </td>
            </tr>
            <tr>
                <th scope="row">6</th>
                <td>GCAllocationTick_V4</td>
                <td>
                    <p class="left-style">Address(win:Pointer), ObjectSize(win:UInt64), AllocationAmount(win:UInt32), AllocationAmount64(win:UInt64), AllocationKind(GCAllocationKindMap), ClrInstanceID(win:UInt16), HeapIndex(win:UInt32), TypeID(win:Pointer), TypeName(win:UnicodeString)</p>
                    <p class="left-style">Периодическое событие выборки (генерируемое после выделения 100 КБ) для информирования о последнем выделенном типе</p>
                </td>
            </tr>
            <tr>
                <th scope="row">7</th>
                <td>GCHeapStats_V2</td>
                <td>
                    <p class="left-style">ClrInstanceID(win:UInt16), FinalizationPromotedCount(win:UInt64), FinalizationPromotedSize(win:UInt64), GCHandleCount(win:UInt32), GenerationSize0(win:UInt64), GenerationSize1(win:UInt64), GenerationSize2(win:UInt64), GenerationSize3(win:UInt64), GenerationSize4(win:UInt64), PinnedObjectCount(win:UInt32), SinkBlockCount(win:UInt32), TotalPromotedSize0(win:UInt64), TotalPromotedSize1(win:UInt64), TotalPromotedSize2(win:UInt64), TotalPromotedSize3(win:UInt64), TotalPromotedSize4(win:UInt64)</p>
                    <p class="left-style">Предоставляет обширную информацию о статистике кучи в целом, включая размеры поколений в конце сборки мусора</p>
                </td>
            </tr>
        </tbody>
    </table>
    <figcaption class="figure-caption">Таблица 3-2. Пример событий ETW, связанных с GC</figcaption>
  </figure>

<p class="justify-style">Если учесть, что каждое событие имеет точную временную метку и может содержать стек вызовов, вы должны начать понимать, какую мощную диагностику можно создать из этих событий. И именно поэтому она используется многими различными инструментами. Некоторые из них будут раскрыты в следующих подразделах.</p>

<p class="justify-style">Не бойтесь, если вы не понимаете описания всех событий ETW, приведенных в <a href="#t-3-2">Таблице 3-2</a>. Очевидно, что необходимы некоторые знания о GC. Мы вернемся ко многим событиям ETW (включая те, что из <a href="#t-3-2">Таблицы 3-2</a>) в следующих главах.</p>

<p class="justify-style">Сеанс NT Kernel Logger также предоставляет много ценной информации, включая такие события, как Windows Kernel\ProcessStart, Windows Kernel\ProcessEnd при запуске и завершении процесса, Windows Kernel\ImageLoad при загрузке динамической библиотеки, Windows Kernel\TcpIpRecv при получении пакетов TCP/IP, Windows Kernel\CSwitch при переключении ЦП с выполнения одного потока на другой, также известном как переключение контекста. Очевидно, что есть и много других, но перечисление здесь лишь небольшой их части не имеет смысла.</p>

<hr class="border-2">
<p id="chapter3-2-6" class="h4 p-2">PerfView</p>

<p class="justify-style">Windows Performance Toolkit был в первую очередь разработан для разработчиков Windows и драйверов. Благодаря его высокой настраиваемости вы можете адаптировать его для разработчиков .NET, как вы сделали в предыдущем разделе. Однако есть еще один инструмент на основе ETW, который изначально был разработан для анализа проблем производительности .NET — PerfView. Его создатель — Вэнс Моррисон, архитектор производительности среды выполнения .NET, и этот инструмент используется командой .NET для заботы о производительности самой платформы и управляемого кода в целом. Более того, этот инструмент имеет полностью открытый исходный код и доступен на GitHub в репозитории microsoft/perfview.</p>

<p class="justify-style">С точки зрения номенклатуры ETW, PerfView является одновременно контроллером и потребителем (предоставляя обширные возможности анализа). Он разработан так, чтобы быть максимально незаметным. Он не требует установки: просто загрузите последнюю версию perfview.exe с <a href="https://github.com/microsoft/perfview/releases" target="_blank">https://github.com/microsoft/perfview/releases</a>. Это упрощает его использование на любом компьютере, включая производственные серверы.</p>

<p class="justify-style">Этот инструмент GUI также может управляться из командной строки и PowerShell для включения сценариев автоматизации. Это особенно полезно при производственном анализе (подготовленная командная строка может быть предоставлена ​​системному администратору для выполнения в ограниченной среде). Например, следующая команда запустит легкую запись сеанса для событий, связанных со сборкой мусора: perfview /GCCollectOnly /nogui / accepteula /NoV2Rundown /NoNGENRundown /NoRundown /merge:true /zip:true collect. С помощью командной строки вы также можете предоставить триггеры остановки сеанса, например, остановить сеанс, когда сборка мусора происходила дольше определенного числа миллисекунд. Пожалуйста, запустите perfview -? для получения дополнительной справки в командной строке.</p>

<p class="justify-style">Хотя настройка проста, первый контакт с этим инструментом может вас напугать. Этот инструмент заслуживает звания самого мощного, но на первый взгляд самого подавляющего инструмента. Интерфейс не является ни интуитивно понятным, ни красивым, поэтому не ясно, с чего начать. К счастью, он предоставляет очень обширную справку. Каждая опция и элемент графического интерфейса сопровождаются ссылкой на соответствующую документацию. Позже вы можете найти некоторые базовые сценарии использования, но мы рекомендуем вам часто посещать разделы справки. Они дают обширные и широкие объяснения тем, затронутых здесь. И чтобы пойти дальше, найдите время, чтобы посмотреть серию обучающих видеороликов, записанных самим Вэнсом и доступных по адресу <a href="https://learn.microsoft.com/en-us/shows/perfview-tutorial/" target="_blank">https://learn.microsoft.com/en-us/shows/perfview-tutorial/</a>. Поверьте, этот инструмент стоит каждой минуты, потраченной на его изучение.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Большая часть функциональности анализа PerfView на основе ETW основана на библиотеке TraceEvent. Мы вернемся к ней в Главе 15, чтобы кратко рассмотреть ее возможности. Хотя PerfView в основном основан на ETW, он также имеет встроенный ETWClrProfiler (основанный на API профилирования CLR), который позволяет PerfView перехватывать вызовы методов .NET (включите .NET Call в диалоговом окне Collect, чтобы начать его использовать).</p>
  </div>
</div>

<p class="justify-style">В то время как пользовательский интерфейс Windows Performance Analyzer основан на диаграммах, PerfView фокусируется на табличном представлении. Почти все, что вы видите в этом инструменте, отображается в табличной форме. Иногда это может вводить в заблуждение, поскольку потребление памяти, стеки вызовов и все остальное анализируются одинаково в том же табличном пользовательском интерфейсе.</p>

<p class="justify-style">После запуска PerfView вы увидите окно с обширными ссылками помощи на панели Welcome to PerfView справа. В это время вы можете выполнить три основных действия:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style">Начните сбор данных ETW с помощью меню «Собрать» ➤ «Собрать» или «Запустить».</p>
    </li>
    <li>
        <p class="justify-style">Начните анализ данных, введя путь к каталогу в текстовое поле под меню и выбрав интересующий вас ETL-файл.</p>
    </li>
    <li>
        <p class="justify-style">Выполните анализ снимка памяти с помощью параметра Память ➤ Сделать снимок кучи.</p>
    </li>
</ul>

<p class="justify-style">Как и в случае с другими инструментами, необходимо настроить пути символов, что можно сделать из меню Файл ➤ Установить путь символов. Лучше всего иметь три установленных источника:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style">Публичный сервер символов Microsoft, тот же, что и в переменной среды _NT_SYMBOL_PATH</p>
    </li>
    <li>
        <p class="justify-style">Путь к подкаталогу с символами изображения NGEN рядом с открытым ETL-файлом, хотя это не является строго необходимым, так как PerfView может автоматически создавать их заново.</p>
    </li>
    <li>
        <p class="justify-style">Путь к файлам символов вашего приложения</p>
    </li>
</ul>

<p class="h5 p-2">Сбор данных</p>

<p class="justify-style">Поскольку PerfView является контроллером ETW, он позволяет управлять сеансом трассировки ETW. После выбора опции Collect вы увидите новое диалоговое окно с большим количеством параметров, и больше можно найти, если развернуть раздел Advanced Options (см. <a href="#f-3-17">Рисунок 3-17</a>).</p>

<figure id="f-3-17" class="figure">
    <img src="content/img/3-17.png" class="img-fluid" alt="Рисунок 3-17" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-17. Диалоговое окно коллекции PerfView с развернутым разделом «Расширенные настройки»</figcaption>
</figure>

<p class="justify-style">Рассматривая доступные опции, вы заметите, что многие из них связаны с .NET. Стоит уделить немного времени, чтобы объяснить их, хотя они также описаны в справке инструмента, когда вы нажимаете на метку каждого флажка. Наиболее интересные опции с нашей точки зрения находятся в разделе Advanced Options:</p>

<ul class="bullet-list ms-1">
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">.NET</span>: Включает события по умолчанию от поставщиков .NET.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">.NET Stress</span>: Включает события от поставщиков .NET, связанные с нагрузочным тестированием самой CLR. Это редкие события, используемые внутри команды CLR.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">GC Collect Only</span>: Отключает всех других поставщиков и включает только поставщика .NET с событиями, связанными с GC. Это очень легкий вариант, который позволяет собирать базовую диагностическую информацию, связанную с GC, в течение длительного времени, не создавая слишком большие файлы ETL (т. е. ~200 МБ за целый день).</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">GC Only</span>: Аналогично предыдущему варианту, в дополнение к включению стеков вызовов для выборочных выделений в куче GC (каждый раз, когда выделяется 100 КБ объектов).</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">.NET Alloc</span>: Собирает стек каждый раз, когда объект выделяется в куче GC. Это очень дорогой вариант, который может замедлить вашу программу на несколько порядков. Этот вариант еще дороже, поскольку он загружает dll-файл профилировщика, который сообщает среде выполнения использовать медленный путь для выделения памяти, чтобы иметь возможность получать уведомления обо всех выделениях.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">.NET SampAlloc</span>: Включает события, генерируемые каждый раз, когда 10 КБ объектов выделяются в куче GC. Как и предыдущий вариант, он не основан на встроенных событиях ETW, а использует API CLR Profiler из внедренной библиотеки ETWClrProfiler в процессы, которые будут выдавать пользовательские события ETW, анализируемые PerfView.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">ETW .NET Alloc</span>: Это позволяет использовать события для выборки распределения, но вместо внедрения библиотеки на основе API Profiler оно основано на событии CSampledObjectAllocation, доступном в .NET Framework 4.5.3. Также обратите внимание, что GC будет использовать медленный путь для распределения для вычисления статистики распределения по типу, поэтому ожидайте возможного влияния на производительность приложения.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Finalizers</span>: Включает события, связанные с процессом финализации внутри GC.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">Additional providers</span>: В этом поле вы можете перечислить любых дополнительных поставщиков, от которых вам нужны события. Его также можно использовать для тонкой настройки поставщиков, которые в любом случае были бы включены. Например, чтобы включить захват стека для исключений CLR, вы можете ввести</p>
        <p class="justify-style"><span class="fw-bold fst-italic">Microsoft-Windows-DotNETRuntime:ExceptionKeyword:Always:@ StacksEnabled=true</span></p>
        <p class="justify-style">Также предоставляется обширная справка по использованию этого поля.</p>
    </li>
    <li>
        <p class="justify-style"><span class="fw-bold fst-italic">CPU Ctrs</span>: Этот счетчик позволяет вам включать низкоуровневые счетчики, связанные с ЦП, такие как неверные предсказания ветвлений или промахи кэша. Имейте в виду, что вам придется отключить виртуализацию Hyper-V, чтобы иметь доступ к этим событиям.</p>
    </li>
</ul>


<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Помимо рассмотренных опций для .NET, есть некоторые общие настройки, о которых следует помнить:</p>
    <ul class="bullet-list ms-1">
        <li>
            <p class="justify-style"><span class="fw-bold fst-italic">Zip</span>: Упаковываем файлы в архив, чтобы можно было легко перенести все это для последующего анализа на другом компьютере.</p>
        </li>
        <li>
            <p class="justify-style"><span class="fw-bold fst-italic">Merge</span>: Объединение файлов в один, но без создания отдельного ZIP-файла.</p>
        </li>
    </ul>
  </div>
</div>

<p class="justify-style">Вы можете пропустить эти две опции, если планируете проводить анализ на той же машине. Однако крайне важно отметить опцию Merge, если вы планируете проводить анализ на другой машине. Опция merge включает подготовку разрешения символов, поэтому если вы ее пропустите, большая часть собранных данных будет бесполезна на другом компьютере.</p>

<p class="h5 p-2">Анализ данных</p>

<p class="justify-style">С помощью PerfView вы можете открывать файлы .ETL, записанные как PerfView, так и любым другим инструментом контроллера ETW. После открытия образца файла ETL вы увидите тот же вид, что и на <a href="#f-3-18">рисунке 3-18</a>. С левой стороны доступны все подготовленные анализы — в зависимости от того, какие поставщики и какие события были выбраны во время записи сеанса.</p>

<figure id="f-3-18" class="figure">
    <img src="content/img/3-18.png" class="img-fluid" alt="Рисунок 3-18" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-18. Пример ETL-файла, открытого в PerfView</figcaption>
</figure>

<p class="justify-style">Одним из самых базовых представлений является общая панель Events, позволяющая просматривать экземпляры всех записанных событий. Когда вы открываете ее и вводите «GC» в поле Filter, вы увидите все события DotNetRuntime, связанные с GC (см. <a href="#f-3-19">рисунок 3-19</a>).</p>

<figure id="f-3-19" class="figure">
    <img src="content/img/3-19.png" class="img-fluid" alt="Рисунок 3-19" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-19. PerfView – события, связанные с GC, отображаемые на панели События</figcaption>
</figure>

<p class="justify-style">Как вы видите, были записаны события многих процессов .NET (sb и w3wp в файле-образце). Вам следует ввести «w3wp» в текстовом поле Process Filter и нажать Enter, чтобы вывести только события для этого процесса. Помните, что PerfView записывает события, испускаемые поставщиками всех запущенных процессов.</p>

<p class="justify-style">В дополнение к стандартным столбцам, связанным с каждым событием, есть также столбец Rest, содержащий поля полезной нагрузки события. Вы также можете выбрать определенное поле, нажав кнопку Cols. Например, отфильтруйте все события, кроме события Microsoft-Windows-DotNETRuntime/GC/HeapStats, введя часть его имени в поле Filter (например, HeapSt). Затем используйте кнопку Cols, чтобы выбрать все поля GenerationSize. Теперь вы должны увидеть таблицу статистики GC (см. <a href="#f-3-20">рисунок 3-20</a>), которую можно вставить в Excel для более простого анализа.</p>

<figure id="f-3-20" class="figure">
    <img src="content/img/3-20.png" class="img-fluid" alt="Рисунок 3-20" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-20. PerfView – настраиваемый вид событий, связанных с GC</figcaption>
</figure>

<p class="justify-style">Однако просмотр и анализ отдельных событий ETW утомителен. Когда дело доходит до анализа памяти .NET, самым важным представлением, несомненно, является представление GCStats, доступное из Memory Group в главном окне. Это представление включает в себя полную агрегированную информацию о поведении GC, включая статистику выполненных GC (см. <a href="#f-3-21">рисунок 3-21</a>). Мы будем довольно часто рассматривать это представление в этой книге.</p>

<figure id="f-3-21" class="figure">
    <img src="content/img/3-21.png" class="img-fluid" alt="Рисунок 3-21" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-21. PerfView – вид GCStats</figcaption>
</figure>

<p class="justify-style">Кроме того, как вы могли видеть в столбце Rest на рисунке 3-19, выбранные события имеют атрибут <span class="fw-bold fst-italic">HasStack = "True"</span>. Если вы хотите увидеть трассировку стека события, выберите одно из них и выберите Open Any Stacks в его контекстном меню (но будьте осторожны, вы должны щелкнуть правой кнопкой мыши в столбце Time MSec). Это откроет еще одно очень популярное представление PerfView: дерево вызовов (см. <a href="#f-3-22">рисунок 3-22</a>).</p>

<figure id="f-3-22" class="figure">
    <img src="content/img/3-22.png" class="img-fluid" alt="Рисунок 3-22" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-22. PerfView – дерево вызовов</figcaption>
</figure>

<p class="justify-style">Помните, если имя функции не распознано, выберите в контекстном меню пункт «Поиск символов», чтобы получить соответствующие символы.</p>

<p class="justify-style">Есть также много других, крайне полезных видов. Мы будем использовать их много раз в книге.</p>

<p class="h5 p-2">Снимки памяти</p>

<p class="justify-style">При выборе Take Heap Snapshot в меню Memory появляется окно Collecting Memory Data. Используйте поле Filter, чтобы найти интересующий вас процесс. После того, как вы выбрали его и нажали кнопку Dump GC Heap, вам нужно будет подождать несколько секунд, чтобы получить результаты. В главном окне PerfView должен появиться новый узел с именем процесса с суффиксом .gcdump. Разверните его и дважды щелкните узел Heap Stacks, чтобы получить более подробную информацию о выделенных объектах (см. <a href="#f-3-23">рисунок 3-23</a>).</p>

<figure id="f-3-23" class="figure">
    <img src="content/img/3-23.png" class="img-fluid" alt="Рисунок 3-23" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-23. PerfView – просмотр снимков памяти</figcaption>
</figure>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Снимок памяти — это не типичный дамп памяти — он не содержит всю память процесса. Это вид графика выделенных объектов (без содержимого их полей) и игнорирование всех неуправляемых областей памяти.</p>
  </div>
</div>

<p class="justify-style">Обычное табличное окно отобразит справочное дерево, в котором узлы являются типами объектов или категориями типов. Например, изначально выбранная вкладка «По имени» показывает сводку всех экземпляров, найденных в памяти, сгруппированных по типу. Вы можете дополнительно исследовать данную запись, выбрав Память ➤ Просмотр объектов (или Alt+O) в контекстном меню. Давайте сделаем это для записи «[static vars]», чтобы увидеть список всех статических переменных в дампе памяти (см. <a href="#f-3-24">рисунок 3-24</a>).</p>

<figure id="f-3-24" class="figure">
    <img src="content/img/3-24.png" class="img-fluid" alt="Рисунок 3-24" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-24. PerfView – список всех статических переменных в памяти.</figcaption>
</figure>

<p class="justify-style">Здесь вы видите пары строк, указывающие, где была объявлена ​​данная статическая переменная и объект, назначенный ей, если таковой имеется. Если мы развернем этот объект, мы сможем исследовать его дальше, перемещаясь по всем его потомкам (полям).</p>

<p class="justify-style">Самая важная функция, связанная со снимками памяти, — это возможность их сравнения. Это позволяет быстро определить причину утечек памяти. Чтобы сравнить два снимка (созданных точно так же, как и раньше), откройте их оба и в меню Diff выберите опцию сравнения со вторым файлом. Вы увидите Diff Stacks, которые будут отображать данные аналогично одному снимку, но с важным отличием: значения столбцов будут указывать разницу между двумя файлами (см. <a href="#f-3-25">рисунок 3-25</a>).</p>

<figure id="f-3-25" class="figure">
    <img src="content/img/3-25.png" class="img-fluid" alt="Рисунок 3-25" max-width="600">
    <figcaption class="figure-caption">Рисунок 3-25. PerfView – разница в снимке памяти</figcaption>
</figure>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Обратите внимание, что опция Freeze отключена по умолчанию в диалоговом окне Collecting Memory Data. Она контролирует, хотите ли вы остановить весь процесс во время создания снимка кучи. Это, очевидно, очень навязчиво, но даст более точные результаты. В производственной среде вам иногда может потребоваться отключить опцию Freeze, это к сожалению, может привести к несогласованным данным (поскольку снимок создается, пока приложение продолжает выделять объекты).</p>
  </div>
</div>

<p class="justify-style">Настоящая сила PerfView — это низкие накладные расходы и способность анализировать производственные среды. Вы можете использовать его для мониторинга производительности в течение ограниченного периода времени или устранения неполадок в производстве. Он может собирать огромное количество данных, и с помощью этого инструмента можно диагностировать большинство проблем, связанных с производительностью или памятью. Единственным недостатком является крутая кривая обучения с очень общим пользовательским интерфейсом и всеми функциями, скрытыми здесь или там.</p>

<p class="justify-style">Конечно, вам следует быть осторожными с объемом информации, которую вы хотите собрать. Хотя накладные расходы инструмента невелики, сбор слишком большого количества событий не подойдет для использования в производстве. Сбор информации от нескольких поставщиков и нескольких выбранных ключевых слов не должен быть проблемой. Однако, как вы можете себе представить, сбор информации о стеке вызовов каждого выделения объектов приводит к неприемлемым накладным расходам. Самый простой принцип всегда является лучшим — прежде чем запускать желаемый набор данных, собранных в производственной среде, протестируйте его в своей предпроизводственной среде, чтобы увидеть, как он влияет на приложения и всю систему.</p>

<hr class="border-2">
<p id="chapter3-2-7" class="h4 p-2">Инструмент dotnet-trace CLI</p>

<p class="justify-style">Кроссплатформенным эквивалентом PerfView для сбора событий является инструмент CLI dotnet-trace. Команда collect записывает события из приложения, идентифицированного по идентификатору процесса с помощью -p. События сохраняются в файле с именем процесса в качестве префикса, за которым следуют дата и время, разделенные _. Используйте параметр -o, чтобы задать другое имя файла. Формат файла .nettrace понимается PerfView, где вы сможете анализировать события, как описано в предыдущем разделе. Однако также возможно сохранять события в формате Chromium или Speedcope с помощью параметра --format &lt;Chromium | Speedscope&gt;. Используйте параметр --duration, чтобы попросить dotnet-trace остановить запись после заданной продолжительности (в формате дд:чч:мм:сс).</p>

<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-body">
    <p class="card-text justify-style">Инструкции по установке см. в предыдущем разделе CLI.</p>
  </div>
</div>

<p class="justify-style">Как и в случае с PerfView, вам нужно выбрать события, которые вы хотите записать. Здесь существуют те же понятия поставщика событий, ключевого слова и детализации. По умолчанию, в дополнение к некоторым событиям от поставщика Microsoft-Windows-DotNETRuntime, также включен пользовательский поставщик записи обхода стека с именем Microsoft-DotNETCore-SampleProfiler. Это позволяет вам анализировать выполнение потоков вашего приложения, однако влияние на производительность заметно. Кроме того, с этим профилем по умолчанию некоторые события GC, такие как AllocationTick, не записываются. Чтобы облегчить вам жизнь, был определен набор профилей, которые можно перечислить с помощью команды dotnet trace list-profiles:</p>

<figure class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cli">
cpu-sampling  - Полезно для отслеживания использования ЦП и общей информации о времени выполнения .NET.
                Это вариант по умолчанию, если профиль или поставщики не указаны.
gc-verbose    - Отслеживает коллекции сборки мусора и выборку выделения объектов.
gc-collect    - Отслеживает коллекции GC только с очень низкими накладными расходами.
database      - Захватывает команды базы данных ADO.NET и Entity Framework Core.
            </code>
        </div>
    </pre>
</figure>

<p class="justify-style">Вы также можете выбрать ключевые слова и уровень детализации для определенных поставщиков с помощью параметра --providers со следующим синтаксисом:</p>

<figure class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cli">
--providers Microsoft-Windows-DotNETRuntime:40000001:5
            </code>
        </div>
    </pre>
</figure>

<p class="justify-style">Первое числовое значение — это ключевые слова в шестнадцатеричном формате, за которыми следует уровень детализации. Если вам нужно сосредоточиться только на поставщике Microsoft-Windows-DotNETRuntime и вы не знаете числовые значения ключевых слов наизусть, смело используйте --clrleventlevel &lt;от 0 до 5 для уровня детализации&gt; с --clrevent, за которым следует имя ключевого слова, разделенное знаком +:</p>

<figure class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cli">
--clrevents gc+stack --clreventlevel 5
            </code>
        </div>
    </pre>
</figure>

<p class="justify-style">Начиная с .NET 5.0, вы можете использовать -- для запуска приложения и записи его событий. Это полезно, если вам нужно диагностировать проблемы при запуске:</p>

<figure class="figure">
    <pre class="cli">
        <div class="px-5 border border-secondary">
            <code class="language-cli">
dotnet trace collect --providers Microsoft-Windows-DotNETRuntime:40000001:5 --show-child-io
-- C:\Apps\Simulator.exe
            </code>
        </div>
    </pre>
</figure>

<p class="justify-style">Параметр --show-child-io позволяет вам взаимодействовать с процессом, если он запущен как консольное приложение, и гарантирует, что вы получите все события с начала приложения. Обратите внимание, что если вы используете --duration, порожденный процесс будет завершен, когда dotnet-trace закончит запись.</p>

<hr class="border-2">
<p id="chapter3-2-8" class="h4 p-2">Инструмент dotnet-gcmon CLI</p>

<p class="justify-style">Текст ...</p>

<p class="justify-style">Текст ...</p>

<p class="justify-style">Текст ...</p>

<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-9" class="h4 p-2">ProcDump, dotnet-dump</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-10" class="h4 p-2">dotnet-gcdump CLI инструмент</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-11" class="h4 p-2">WinDbg</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-12" class="h4 p-2">dotnet-dump для анализа</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-13" class="h4 p-2">Дизассемблеры и декомпиляторы</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-14" class="h4 p-2">BenchmarkDotNet</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-15" class="h4 p-2">Инструменты от авторов</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-2-16" class="h4 p-2">Коммерческие инструменты</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-3" class="h3 p-2">Резюме</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter3-3-1" class="h4 p-2">Правило 5 — Раннее измерение работы сборщика мусора (GC)</p>
<p class="justify-style">Текст ...</p>



<!--
Глава 3: Измерение памяти  
    Начинайте измерять на ранней стадии  
        Накладные расходы и инвазивность  
        Выборка против трассировки  
        Дерево вызовов  
        Графы объектов  
        Статистика  
        Латентность против пропускной способности  
        Дампы памяти, трассировка, отладка в реальном времени  
    Окружения Windows и Linux  
        Обзор  
        VMMap  
        Счетчики производительности .NET Framework  
        Счетчики .NET Core  
        Трассировка событий для Windows  
        PerfView  
        Инструмент dotnet-trace CLI  
        Инструмент dotnet-gcmon CLI  
        ProcDump, dotnet-dump  
        dotnet-gcdump CLI инструмент  
        WinDbg  
        dotnet-dump для анализа  
        Дизассемблеры и декомпиляторы  
        BenchmarkDotNet  
        Инструменты от авторов  
        Коммерческие инструменты  
    Резюме  
      Правило 5 — Раннее измерение работы сборщика мусора (GC)
-->