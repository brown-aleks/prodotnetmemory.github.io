<p id="chapter4" class="h2 p-2">Глава 4: Основы .NET</p>

<hr class="border-2">

<p class="justify-style">Хотя мы находимся только в четвертой главе, мы уже прошли довольно длинный путь, изучая различные аспекты управления памятью. Они обсуждались в общем виде, чтобы сделать более теоретическое введение в эту тему. Упоминания .NET были редкими, несмотря на то, что это основная тема книги. Пришло время изменить этот баланс. С этой главы и до конца книги .NET будет сопровождать нас постоянно. В этой главе мы рассмотрим его с несколько более широкой перспективы, вы узнаете о некоторых механизмах, лежащих в его основе, и начнем углубляться в темы, связанные с тем, как он управляет памятью. Мы настоятельно рекомендуем вам уделить время и прочитать предыдущие три главы, прежде чем продолжать чтение этой. Отныне мы также будем предполагать наличие базовых знаний о языке ассемблера для платформ x86/x64, так как мы будем углубляться все дальше и дальше в .NET. Если вам нужно освежить знания, прочитайте, например, отличную книгу «Modern X86 Assembly Language Programming 3rd edition» Дэниела Куссвура (Apress, 2023).</p>

<p class="justify-style">Платформа .NET Framework была представлена публике в июле 2000 года на конференции Professional Developers Conference во Флориде. Это продукт, который разрабатывается и используется уже более двух десятилетий. За этот период как богатая коллекция сопровождающих библиотек, так и сама среда выполнения значительно эволюционировали. Разработчикам .NET необходимо хорошо знать базовые темы — знание стандартной библиотеки и синтаксиса C#. Это наш «повседневный хлеб». Кроме того, .NET Core привнес новые функции и инструменты, которые поддерживают не только Windows как платформу. Цель этой главы — немного углубиться в .NET и его основы.</p>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Имейте в виду, что эта книга сосредоточена на управлении памятью, лишь кратко упоминая другие темы, связанные с .NET. Таким образом, не ожидайте, например, подробного описания возможностей языка C# или рассмотрения вопросов многопоточности. Существует множество других замечательных книг и онлайн-материалов, посвященных исключительно этим темам.</p>
  </div>
</div>

<hr class="border-2">
<p id="chapter4-1" class="h3 p-2">Версии .NET</p>

<p class="justify-style">Среда .NET не так однородна, как может показаться на первый взгляд. .NET Framework, предназначенный только для Windows, развивался от версии 1.0 через версии 2.0, 3.5 или 4.0 до текущей версии 4.8. Кроссплатформенный .NET Core начался с версии 1.0, за которой последовали версии 2.x, 3.0 и 3.1, после чего он сменил название на просто «.NET» с версиями 5, 6, 7 и теперь 8. С самого начала вся концепция .NET основывалась на спецификации, называемой Common Language Infrastructure (CLI). Этот фундаментальный технический стандарт (стандартизированный как ECMA-335 и ISO/IEC 23271 в 2003 году) описывает концепцию кода и среды выполнения, которая позволяет использовать его на разных машинах без перекомпиляции. Мы будем ссылаться на него много раз в этой главе, так как нет более надежного источника информации, чем этот.</p>

<p class="justify-style">Описание всех компонентов CLI, включая все варианты реализации и различия между ними, очень заманчиво. Однако мы в основном сосредоточимся на том, как они влияют на тему, которая нас интересует. Сейчас давайте просто взглянем на различные вариации .NET в контексте управления памятью и сборки мусора (Garbage Collection):</p>

<ul class="bullet-list ms-1">
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">.NET Framework 1.0–4.8.1</span>: Выпущенный в 2002 году, это коммерческий и наиболее зрелый продукт, известный всем нам. Он доступен уже много лет, и ядро сборщика мусора (Garbage Collector) разрабатывалось и улучшалось от версии к версии. На протяжении многих лет эта тема рассматривалась как «черный ящик», описываемый более или менее поверхностно по случаю выпуска новых версий .NET. Поскольку коммерческий код среды выполнения .NET Framework закрыт, документация, предоставляемая Microsoft, была единственным способом узнать, как работают эти механизмы. Информация была достаточно подробной, что позволяло понимать и диагностировать проблемы с памятью в приложениях. Однако разработчики все же оставались немного неудовлетворенными, особенно если сравнивать это с открытостью исходных кодов, например, в Java.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Shared Source CLI (также известный как Rotor)</span>: Выпущенный в 2002 году (версия 1.0) и 2006 году (версия 2.0), это реализация среды выполнения для образовательных и академических целей. Он никогда не предназначался для запуска производственного кода. Он позволяет заглянуть в многочисленные детали реализации CLR. Даже существует отличная книга «Shared Source CLI Essentials» Дэвида Штуца, Теда Ньюарда и Джеффа Шиллинга (O’Reilly Media, 2003), которая подробно описывает эту реализацию. Однако она не полностью реализовывала «зрелую» версию .NET Framework 2.0. Более того, ее реализация иногда сильно отличалась от полноценной CLR, к сожалению, особенно в области управления памятью. Там был реализован только очень упрощенный сборщик мусора (Garbage Collector).</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">.NET Compact Framework</span>: «Мобильная» версия .NET, начиная с времен Windows CE/Mobile и Xbox 360. Ее сборщик мусора (Garbage Collector) значительно отличался от основной версии и был намного упрощен, например, он не включал концепцию поколений (о которой вы узнаете в следующей главе). Однако это уже историческая система, и вероятно вам больше не нужно о ней беспокоиться. Но множество уроков было извлечено в процессе разработки этой платформы, особенно из-за портирования на различные платформы с разными процессорами. Именно здесь концептуально начался .NET Core.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Silverlight</span>: Плагин для веб-браузера, который позволял запускать веб-приложения как обычные оконные приложения. Поскольку Microsoft начала разработку примерно в то же время, что и .NET Framework 3.0, он был основан на копии среды выполнения того периода.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">.NET Core или просто .NET, начиная с версии 5.0</span>: Многое изменилось с появлением открытой версии .NET. Теперь у нас есть готовый к использованию в производстве код среды выполнения, который мы можем изучать самостоятельно и в деталях. Что еще важнее, код сборщика мусора (Garbage Collector) был практически скопирован сюда из коммерческого кода среды выполнения, поэтому изучение .NET Core дает понимание того, как GC реализован в .NET Framework, особенно учитывая, что новые функции теперь сначала реализуются в .NET Core, а затем переносятся в .NET Framework. .NET Core также является официально поддерживаемым кроссплатформенным решением. Он работает на Windows, Linux и MacOS, а также поддерживает процессоры ARM64.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Windows Phone 7.x, Windows Phone 8.x, и Windows 10 Mobile</span>: Более ранние версии системы были основаны на простом управлении памятью, известном из .NET Compact Framework 3.7. Windows Phone 8.x представил значительные улучшения внутренней среды выполнения .NET, которая была основана на зрелой версии .NET Framework 4.5, унаследовав ее сборщик мусора (Garbage Collector).</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Native AOT (эволюция .NET Native и CoreRT)</span>: Технология, которая позволяет компилировать CIL-код напрямую в машинный код. Она основана на облегченной среде выполнения под названием CoreRT (ранее MRT). Они используют общий код сборщика мусора (Garbage Collector) с .NET Core.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">.NET Micro Framework</span>: Отдельная реализация для небольших устройств с открытым исходным кодом. Наиболее популярным приложением является .NET Gadgeteer, который содержит собственную упрощенную версию сборщика мусора (Garbage Collector). Из-за нишевого и любительского характера этого решения мы не будем рассматривать его в этой книге.</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">WinRT</span>: Новый способ предоставления функциональности ОС разработчикам, который представляет собой набор API, используемых для создания приложений в стиле Metro, доступных на языках JavaScript, C++, C# и VB.NET, и призван заменить Win32. Он написан на C++ и, по сути, не является реализацией .NET. Однако он объектно-ориентирован и основан на формате метаданных .NET, поэтому может выглядеть как обычная библиотека .NET (особенно при использовании из .NET).</p>
  </li>
  <li>
    <p class="justify-style"><span class="fw-bold fst-italic">Mono</span>: Совершенно отдельная кроссплатформенная реализация CLI с собственным управлением памятью. Знакомство с ней мало что дает для понимания основной темы .NET. Однако существует как минимум два очень популярных решения, основанных на этой технологии — Xamarin, фреймворк для написания мобильных приложений, и Unity, популярный игровой движок. Кроме того, фреймворк Blazor WebAssembly также использует Mono в качестве базовой среды выполнения (перекомпилированной в WASM) для выполнения управляемого кода внутри браузера. Из приведенного списка складывается довольно положительная картина — механизм управления памятью очень похож (если не сказать практически идентичен) для всех основных реализаций CLI, используемых в настоящее время — .NET Framework, .NET Core и той, что используется в .NET Native.</p>
  </li>
</ul>

<br>
<div class="card text-bg-info mb-3 bg-opacity-10">
  <div class="card-header"><i class="bi bi-info-square"></i> Примечание</div>
  <div class="card-body">
    <p class="card-text justify-style">Эта книга полна объяснений о внутренних механизмах сборщика мусора (Garbage Collector) в .NET, основанных на исходном коде .NET 8. Как мы уже упоминали, существует значительное сходство этой реализации с основной версией .NET Framework и мобильной вариацией. В результате, опора на исходный код .NET Core является очень ценным и всеобъемлющим способом получения информации. В дальнейшем, когда мы будем показывать примеры исходного кода .NET, по умолчанию будем иметь в виду исходный код .NET 8.0, если не указано иное. Мы также ссылаемся на так называемую открытую документацию «Book of the runtime», разработанную параллельно с самой средой выполнения, доступную по адресу <a href="https://github.com/dotnet/runtime/tree/main/docs/design/coreclr/botr" target="_blank">https://github.com/dotnet/runtime/tree/main/docs/design/coreclr/botr</a>. Она содержит много ценной информации о реализации среды выполнения.</p>
  </div>
</div>

<p class="justify-style">Чтобы полностью понять тему управления памятью, вам следует знать некоторые внутренние аспекты .NET. Мы рассмотрим их сейчас, однако, опустив много информации, которая не нужна в данном контексте. Существует множество других ценных источников, где вы найдете больше информации, включая замечательную книгу «CLR via C#» Джеффри Рихтера (Microsoft Press, 2012), «Pro .NET Performance» Саши Гольдштейна (Apress, 2012) и «Writing High-Performance .NET Code» Бена Уотсона (Ben Watson, 2014).</p>

<hr class="border-2">
<p id="chapter4-2" class="h3 p-2">Внутреннее устройство .NET</p>

<p class="justify-style">Текст ...</p>

<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-2-1" class="h4 p-2">Пример программы в деталях</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-3" class="h3 p-2">Сборки и домены приложений</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-3-1" class="h4 p-2">Собираемые сборки</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4" class="h3 p-2">Области памяти процесса</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-1" class="h4 p-2">Сценарий 4-1 — Насколько велика моя программа в памяти?</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-2" class="h4 p-2">Сценарий 4-2 — Использование собственной памяти моей программой продолжает расти</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-3" class="h4 p-2">Сценарий 4-3 — Использование виртуальной памяти моей программой продолжает расти</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-4" class="h4 p-2">Сценарий 4-4 — Использование управляемой памяти моей программой продолжает расти с ростом количества сборок</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-4-5" class="h4 p-2">Сценарий 4-5 — Моя программа не может выгрузить плагины</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5" class="h3 p-2">Система типов</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5-1" class="h4 p-2">Категории типов</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5-2" class="h4 p-2">Хранилище типов</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5-3" class="h4 p-2">Значимые типы</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-5-4" class="h4 p-2">Ссылочные типы</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-6" class="h3 p-2">Строки</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-6-1" class="h4 p-2">Интернирование строк</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-6-2" class="h4 p-2">Сценарий 4-6 — Использование памяти моей программой слишком большое</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-7" class="h3 p-2">Упаковка и Распаковка</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-8" class="h3 p-2">Передача по ссылке</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-8-1" class="h4 p-2">Передача по ссылке экземпляра значимого типа</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-8-2" class="h4 p-2">Передача по ссылке экземпляра ссылочного типа</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-9" class="h3 p-2">Null</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-10" class="h3 p-2">Локализация данных типа</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-11" class="h3 p-2">Статические данные</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-11-1" class="h4 p-2">Статические поля</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-11-2" class="h4 p-2">Внутренние статические данные</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-12" class="h3 p-2">Резюме</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-12-1" class="h4 p-2">Структуры</p>
<p class="justify-style">Текст ...</p>

<hr class="border-2">
<p id="chapter4-12-2" class="h4 p-2">Классы</p>
<p class="justify-style">Текст ...</p>


<!--
Глава 4: Основы .NET
    Версии .NET
    Внутреннее устройство .NET
        Пример программы в деталях
    Сборки и домены приложений
        Собираемые сборки
    Области памяти процесса
        Сценарий 4-1 — Насколько велика моя программа в памяти?
        Сценарий 4-2 — Использование собственной памяти моей программой продолжает расти
        Сценарий 4-3 — Использование виртуальной памяти моей программой продолжает расти
        Сценарий 4-4 — Использование управляемой памяти моей программой продолжает расти с ростом количества сборок
        Сценарий 4-5 — Моя программа не может выгрузить плагины
    Система типов
        Категории типов
        Хранилище типов
        Значимые типы
        Ссылочные типы
    Строки
        Интернирование строк
        Сценарий 4-6 — Использование памяти моей программой слишком большое
    Упаковка и Распаковка
    Передача по ссылке
        Передача по ссылке экземпляра значимого типа
        Передача по ссылке экземпляра ссылочного типа
    Null
    Локализация данных типа
    Статические данные
        Статические поля
        Внутренние статические данные
    Резюме
        Структуры
        Классы
-->
